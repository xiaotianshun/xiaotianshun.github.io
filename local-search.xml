<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面经show</title>
    <link href="/2021/03/25/%E9%9D%A2%E7%BB%8Fshow/"/>
    <url>/2021/03/25/%E9%9D%A2%E7%BB%8Fshow/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5815aab4900e315ba20605d636ccb9107ccb10fd16b2790465bf0857bd510bff">cc15b0e9d728d988ef0ca444f2d3f6f64112dd0511fe7f8d00b764f9387c96764fc2a76fad169cc5cac4d8f814cf546513ae3aa1d25601dd96adc6701e12542ab6e1bbcc71113e2b5327d27ff42e3c39a0c62e6e1e8395575f30f1e20f390dd2be60fce68e41cb2956c9eaf19db5beef4afb0f91df40b62d3fd08ec1c46c2fda8ffcbb100521b3f36995006ead8e0fdcf98a1240b3e77949a52d5ef5a95bcec24aca9a91ffa738e4439d8c7e1feaf90f75fcdb8737e042867df5362461ddda46511f7fb34def40c4f6d3401bb71eb30dd28732273ccf3bf8f35b74a36f545494cf04c48378f31c0715e7758618c6e33a3c02b238e1013a223232d129e2fa6ce66cb8ef715a83bc3beb4810a185fe3c41de8c5e11e630ad077ba1265298c64481c03ede3298dcd99f2d4eabd75c6029b56ccd87f4f54713fe1126089cac6df6c7f9fd8a69ff1877f73f0d4afacc170a2871b8e128f9d96e237b17b808f05cb8e924f8938eadc1663f77cd507986919d7f21ee457e39ae21f79dee8e0f9e121efc30613caa0dbc9e41bcf073d9a7645b64633aeeb0eeb1edeb7ac6038ff2fc29eb12d21c2c79db933e64f78c3e1acc0fc0309a4738425884e31769437e0b74293dcf804f62f375cc9d96d460727b77f5f5d3014fccefc6b4ca4aa88a4c5e12c6de0d2749beaf64df2b9703354f0b3927704fd7c15c1b11e3d33dd6202578fc86895d5efdac7a78dd5da56d186bbb41bfc8d6db57c173e371cbfbc74690452f092cb41fd06968978837001852e7170648c5d9241b197791eada6c3bf3026714d92cb0b05be6a4d13d8e721e4453a621e6c5043925aed1bef8467a9f7f7900d9a0f202e798e0e7e1958dda0b8edbd349ce2d64dc37e728425b5dc9c4d1eff64d4d0ccd144c66822d010782837fd4953ef13920e1b44ef70a4ec110323ea80cc5351b2200b1eb21bc35817125e13c43020d779945cdfcb475cc56f6ee76c07160003c30940a26c6943a9a8c904b471d921cde94215d61bb131a5a82b0844000a6e30f63fbd6f16ea03893e9646738eb77866ae0f743fcbb4dea51c5b5a51db28dda82f8722e50a8453db06f5c4cb8f492cb1d5ad0d0e4ae6dd31aae3a879c38aad0abc0f6c80099e33737b14ae1ab259e47ce4176121376a88de7cb80b9bbf4414e46362ff0f2f41a253c15e54563575467e74e5d58cf0017db2fd102efb9f1bbaecf174886d475fdbba2c3e846145278ad67272f23062eacd9c206595d3923a2bb3cad7c6c01b8fd01c4ab50a26221af1970d6999c01f5620b2b441840550a4aee34d12609cef000b266a2b5561edc69d5e89b14f5cba2370b8a193c56754503a1e041569875209fe83c879f2041dc65a78fecf8a300828e756a668b3d5a17db27226e5c2a4981bea544044536743e340388dd91284347c5ebc42c0a23938f5fae51b2894f64944295cd1f44e3866091383cfc4deceea0e56e48c70bed51b055560b71659118b5de59e2df7cb02a6487fda719aeb2d3efadb29200ba5582293246bafd03bc8e65b05636d112cf5c93ac4c12db6d1e7c597eae12f50e9b2d0efd2c696f0dc39b280512d69f5b0b2643d3170153a1bed857655f62641a9ac1fa211fc7b66412b0b6e6873027b5dec309d18ac34da92ffcf692a6fc3ff8466541250433c7bd31310679ec365f46b9c62e9f3403e88198991e102b26a604c09a815267c8eeb25dba6bfa34b44a13deb856e32748b7f8a7b9b58e9cac9e31799fba5167daffd542b4b74f2d6f54bc424e83e6c8dd8d7e2c7e4ff3e82f322ac9cd6a8b9b09b43eb1a0bdc1939c20ddcdeb2d07b0d809b54b2b9d10c1e0a6e2ba12073d3b136fb3ecd86ecb108826ff94bf04d5a782bb0447b0197b22a217e3f4fb00bbce9ba5a76035723aed36497f767439d5745139690d6a2ef3c9e14073f2f453a7770d67ad1ccf2e2ffd29f695700be6bc410c739706ab190a4903dd94b538d079724e8ca8acf8aa6097e23fe67445005e003152c736e0dd5bcd3a97f1bdb74b37045ac0087fae8c810f515e024df9a56cd61a64a072369438d6dfc062d770bef8a03487e0756fdbf8cfc9b8529653e4449a52c18bee9d07489e830dab06c920239a9fa553d28d60bb4fe2d1b11394e8185ff157dcefe87d00fd708aa39ef230c90c3ec936958fc65e33db66f071f1d3bf5a6615446306f106641656c83320911b073b1da3e5ff7cd9af9e054ac7dbb212f1ea87f88300e136a550cc1c298424498e2ba70a1aa3a180325649c8b178f03046579ee058790c5dbb34b13ec45e6b65317ed03b9e09c9bbe7183f448e7b1e6f3d741bf1a150fa85306b98e3f8c4fc85e5562bf4f06369bccc44085262397c2192baa1e43eec143fd167f017b6696ab103397e51a983b22f76bfd544b40b375ff60e148b22a651195c28072931da97c31cb9272c5d46c899613093a55e67fa437924a9327b096bb276b3eb83febc7bdbf34e4215a60d9f3cd3c38b0c04be42e0cf5d89ad41c28d6e5690e0d6e53fe6c3e1d586a9094d2c350473661a3da5b61f6bd1fc8bf916b4a6764457d7349c5d40dea9908efcd7ca87b8131f142cee1ee32074c967e27daca71ba4f3d89ea0c0d177a4a2d2af2455eb8b38b5bf0b755814a9ab39c77e568e441a6646cd38d61baaa31df2180eaccd9bf3efa50eb3ae08cae0075688888f73c3e781fd8d4c4b532558b051cbff17d970bee8a71f1554e41ddc28a79a141f0a76ce6026825c752a390ef139de9746c72f51219f214fa5c6f54c3e03402cdbbccb49e37e884d018e36b20da13a57aa9df82685cc8164d37f878053ceb03d386b4cfae6bd6a67af8e58ced1e8333f90b16c7f73b7e1e2b19448889af8d92e7a2f56a25aff3923216f223dce0e95e3d9b276d48b7e93f7904dca22e9af03e42fe118b02d4d0298e3b8bd29b9c44bf40cdd44c2da2078e0a2bde9a05d39a159172b3fb936dca9fb0b8e712e743e1aed98fa50bdc169618dabbed951b62b66129c9e65ac01881ff65b3d64666e57726350d13d8f67d286f585abb66181e14a31901b6cb63b3b032dd65706f5206d98f33ab3bcf9a3f4a2a0c9b32d54e603c959db5705158cd57c0740c7b6a571d3799967ff18061353899c84905f7900c6153b8f6c6928128fe35d439eed07819a9ac4623152b9812af145046c8d96d541e15c5b15a5d94a08b6113858709f91de4a447c1c919caa9e65a8a767881bd15502d480aa012ee96a7cd9fff455609b816c11bf0402e77f89666bb80762efed1879a3af82b141123c68bae053fe53317f8c23e039349ff42ad589d1605c346afadc759df8caaa351165f7bf772024f570033a1ce5e600005843b55d1ebccbb9c726d5262ff25acd3e5531935b9e3c11986817d308ca6f71662a028837485c0830b2ce934b5fcdabf6ca76a73087d31673f8caa8bc7991f90b55ed9c38f87c3c24ba4a8d6f3aa4080894298ee85e29560e35ae657dd4f208852e54fa25a102e24a0efb760c9753412b53c13ad40802884a8c79202f55896919f75a6f7242aaceb7e6478b716a2bcb9c54cce2d295a454959474d8cc1b39e264db135e0b180f2fe7aa93e7d736b878039dfa2770f965583fc075735d465b6042a4c9ee60b5df5c5e0344a16d21f9b9afba314385288f6bed25d48bee4f2d9a217db70aa59ea951c692519a97975725a05b331a584809ac460018d5d3036d815df82b865f7251d468b4df27239f84f0bb13ee41bb6890e3b48ed8201e1d49c84cc495a639150b4327319a16fa825bad8b79928c1630be0e30e31a103e61437f87ed73eb77e7e287b5b3c934a2148aaa8701ccb43e5e14c234ce3b437a0b0e8807a65a49cf56a6a0634e5536dcfd7e17bbae5d08424855fc7b40d0a1e64ace18a768975ed48167faaa06a5c85f5cd183521bfb2eb49184afca3e73e6c71f5327b42c8e7179d7547d75c8d4a1845484e29f7f80af84f5837ede5e4ce4fa68a15a17ebdbb2f67c9dd3b70696c71812acb5394de0962de4d01615cdf2ca2b20c1b6fed142ada3e0c5fa8410f19c51f5bfcdea2e0ea1df2b051f843c191de96c529102aa81986c1c5a6da7d89dbd9f9fe5dfb7d09544b6160a6f1709f9d6973a79c2bc77043ad5c2d6edd1ac59ab519f562dc9cf9be5571628f55dccb0676d243fe730620d78d8303e15b45cae6295b822be9ee3a4ebc2300aa72a935d83e8886358d32f05cbc9b1d6943dc8d8418deb0ebffc4c4307e1c035de8347f4ced03e4400eb8c552813507ed222ca86fd5fbca2a2eb90d280cec49194cfc1753f7a964ac62aa2063ad9bf27d3772d9fff0ee05c09667b0173d3eff404ef27f3a0bf8d747a6e049bd791edf7da9e760b4617da74fc211ac025fddd24bcb99fe3c5b7ba30214d5181a80dcc782b9ec6615a06453ccd306142b6a93f6ba61b01c3aaf20775af9a4dbdc3bed84f04131ea7f71e1cc468c6cca99b046b809ce8278b12a587ac7a11bfd438e4a0e1307cfaa03bd71dbb683bb97b80d85cc963c6725088e024052156e1d67db819383cc3cb5d22626b2a0f0039716278668c4f8ff27c2b6ddf608660dd5cb0d6e946ce775627cdc9ddcb7b158f76db9805018c7b113419719c5b5d378ebf53cc875a974be708966f4142867b177bc2474780ba4d066d3b970cd065249fec52b5dd0be86592040e6341c3968097d274a7073c1919adba75311567f8cab97cb8c0b53bb2f2cd44acebbd1a13f43af8f6dea7ac47e77c63eeb109c867e389210cfe1f11aca63c6ba98dbe2c20bc5cfdc082750fe41bdb0b97324e64eb38ec973690ee31ce7a8d61fba7aaa3ad1331fafa137a16459706167d4afde5008e794ed2e1428f3d68ec8928fd9a7eb03289b27b3afd82d0313e4ab2494d88e08eaae3c2deb85d69039fbc9ded4f1f0a86db57e3778ed868562fc42d929e134f2710ee6ffe7c6d26b0781e246e9722664d4d51f96414e401ad295986397d599e8aa5c2a4913ea4330e7d2cd257f3f4534fba4ccad59b6f2dcca7dd3843fc5fcf294119277b4089699314557e00d2aa805627f9db1b196f92c0e8a65fecca7f27ed4c3d33c1640848079d53ec8f40f08d38df8eed7bd540fb4a7f6cc60f5d90e1eac23d58eff9151b55209c64131e1d6a1f3609bd6720c3fd5183cf2f23f730496772a6f5f7f9a0f43f25be9918d0c601fd8f91b82c1a957c375a516e781ca223f419478f9fbbd906b5dacba0159c106809f94fe64cef9c9df464fbf5a92ec29278cac3e998e9815499730b26985b3cf612d3090a6dccf1e7d1d29a4172e2acda905ff90a9a8ba1d3b604966e2a279bc81c60e33057c185ae09710ae3fb32280507c008944bf979d291ab6009f82bc968fff37d27f3bd8337cf4acac56ee0ef77c5ba899ed95ab547032b2cbbae01dc314bedc9d5d84925bf9f7ebafd25b9f24b051415eb8e33a80b0362779f5bff672aa4829d26381f811e8054e4d3f2d482d0a7adac41578d460e1fa443c8d4eed507ca5a1e74fdb5838cc6d4b6cf876cf969e69522540f30f69334a6718ddaba50cb6fccb74f400416f564fb185813995c63f323567a73c54c3a8e4d856b48c3c03058a5e30883eb9d82a7e969ae58e9de684e74d833f93876118a0c7d729ac102e184a6c9b45f4f7a2f82d7191658889c9c2ce9c4097260c3a0e105a7766ec8091aed30e55c8646d076dd8a2dbd2788d3c93839e0708fcb08bb7207ddff0f72675c178722301f370fab1998cb2a20aa55315dfe127d22b3eacf339b405bd2a417ff110a734d1b1e8688797866dc63c3ff533ae57bd097ad5575d80df7c854ba0a9b115e27197e92cf7e3bbbd7ead3d54092521ddd9e6f95b3915dec8e1a71dab655a533c47dbe83ba1035bcd2292b2180750c5b2ced3218d4d7eec10e9a9fd2154af4cc3c930d670e758b5d56dc1f8c004b403de646483d7493b50781d03eb5050351c41b81214cc9704ceacb76f9a1a4ce170fcab021d234157beb0f6808e38d9a31e1bb5a2a2798d96da87b19d873228cc201247c6dc0d3fcd139115a58d18e0dad2f050a5cccffa7615764c5a06af3b76359756d0d6441235975363cdf26432776d846b6aa7bebf9bd42e49eb3202d8cb765a7cb75eefc08a97b910fee03d5c7e88e2feccc2dfe32beb3f7f68055fcf82e5037bfbc391f113da11b41918aaee274b6cd572b06ce5ea251c273d5f274625959e4777b72af707c9f10a4752f7e9041b8b1d4bae7a01503a0cc884e29dd06ec53ee0cba01497b5e61e250aa5586169ae326e634fb06a110e3ca7ccb197a0238e4afa255df977fe0363c1ea898b300779b3ca087f41308c33a9f24f93572c27cdeff116cafe48082b114a92e38c53e8b028bc98d0879624c030fd207b4fc852710965a4e25d47730bf393d7381b17e08f39f5305e3b6c3eafc295e01a71a34be409bcdcc0e0b286287713779957f1c3d715ecd54e7788692d6445425060ebfb20759de173b38fa06461c61d1e497526eda33c8cebe8b36900cbf2d0e4c5bdb4a8d69162db897acbb9c19de73d07177710241e312e1f0589c264184b094a78c94ca8b9ede59941f10a701bf26180471f0b6b01c0956cc478958c78a09255cf9110b1f2e6e74b327e7fa242f27f29ca2412a2dc43e91f86e9326f4cb6af45a5a9047afa0e59c9ca561bf7d705d28093e0c8e724c5fac18a79444755f1104dad4e4615a8cf4232f0d90e23df7fe4ac924849274a51b5b78af8f251d11d85ba7b630d42d4afffc991ad413a49765d9629630e29111f8837d2f256b49919f7d8c3ac61b73d74ad1e4297a6454f9bd2e811826a7e96786e9ee728a7df0e8cafa80d9f90c7aa89dadcf93520697c39b25b6e78f638374beaf11667103640c7ffa5cc4be62859a189002cab962ef246aa1f750d5f14a6020cd63f0e69f514ede38f0bd66e4b0c16c4a30b72cb9a967308f2dcad820db44a3edd0e1f652b2dc574509bc4427fb057fb55a77f81c2d1cd7ff10364525f1b7c134b7911458eacffe33ddb055d6af3bf7cf976ee0196634862a20ac4c660addd3ce44853db4a2b887e048748aff4b37ab167bd1d8cbc8e67916366c1da17aecc34b650d7ed9dd5fdf90635c822409d895a233094dbb5df3e4a2125b642b7eb331f012f256272b60fe1fac824803d03418b23067bb04819d731bd752d6d96369237e325ade236b71d48237fdb3bc6a88607161aafb32fb1b6836c33ccb4c935a83a26e50484415f2fd57ccc0d378d1694dbc1a082fb8acfae5e78b97066154818615ee8f21f68cb0931136e067befed91840aaa29404dacbdf63312a78de2662e53ea551e0958a8ac80e1d4577fa4fd52ccddce7dba216b04bd28f49a328cbea74c677e46f0a4be8ae48051da165ecd80d186f49db7fe0722b7e2eeacae13b8b5b66de9b943ee03a340a7b607b4b535ba88a2a3b2e85fbbbe3e9fc3755c1f305e45cdec1bd0792ae73b94edb5cbd1fda35b47f4992d0de7085b18cd2b0df972e9aac9a1fe40e136126cc4f5203876ab530f10e4c5c95c4e8dab19a92a3b414be48bc5fb0f5f65b9284b954c4e056b017b9c936e09f182005c32926bcb24a6ddce1e4f77ba8d2cf3d95da2be2e7920b9cbec5c381d5b835557e6ae015285afae2170f657a5ab8d1517f4cfadb1e9ca2ee89037c2bd25c5f2497198a1d29ba05c55112fe01a98ce14b170a2eed91ac6c1bb8081266fefea1cb7881e9309e6b3a2beb6180ce6634190d86f09fb44dcf02b12a28fa373a9f2caa9a82ad26158a0ebb7950fddd236bd54583ea80a6b802693c25d1e65048415bf121386ef96c71b68d601f1864ad53008e8883d48b8f1679ea69ae5c0bf3ecb129f09dbbc6642dc7290ca6dd3fce50bb19d3d82e33d33f148620aff30ebcbd471c700a8720f6279039feac824d1d710408729a7db49b3a5520ee62425b55adbd0adda4c1da8089909fad24e80b7a16b788dfa6b96a6d677f84e2835783c9f74d5f6c9678b95971f1d908a76ea944d96486dfbab83e4cbea84c520aaa714050e93f79efa0b5b3a7ecbf6d919940bfc89271538cf4fefdc33422c48310cffc76729fd520d8e56dcafc7f89f1b9cc60710dd1ff9e241c6d65c86a124940bebc78151e031c4c83feb84e760452267e7ee237b616bc6889e2d4caf45d6d578285cfad2fabf14aa585a245b08145126f117eef76f3641a259442ef43accc0ae79a6aa815a98df94d5a4ed75d84c4d5e9cd4003a8b23457f02a28b33803733dd0a7ee89191df8c100105a3c856d6375e591b5a32940f58db2cae1e103647de5611e365f56ff250b913338b451233f94db93701f947d6d1bf39183512673af96eb8416cae8fdd17d3d806852026a29013b81a6e15008813fc75d5c5c96742966d52c170551cb2f57b0c3d96f9f55a0375b5e1e7d6f3f61bc3408676ff9b2279a59793fc9ed8beea3999bec005a7927fbf7a0a466b8e1a0d6989641abc1a9fcf40d23bc2e6680a5e8700e96f7f28969cca94bbb4cdd1eb34bf69d5699edbc1c50428a96038f052e56eeb456ce5ff5768f8112d1c60d9580a50b4cfa339dc2654f6f094b04632b1412e5ad6ca939001a36bb4575d90cb74e93431c2eb2edec8947a0ea25f6de2677957d08bee3869498c744ca23675b7b2fa036542a5a4d854d1af61c16bc0d2690d413cbd5bf3315462bd2f7fe0a30958303c59d3577bf994566f6d55a5ca696696ce18fa161f27410159dc34077747800b28c0fd415a0c5cdf174b74f93ffa21a72a86ff2ad7bd476901fc97f5db93d6382a6289e6fa642752da5b5b26b14f3087bb21eccb99977a9a28602d08e5d6073f57197416d40a77b9355140ef1a1725430de34d06720119638472c6d79b731e316135da60b4d2cb0f20535788b222f0f53d1a5eb737c4e8ba1fa20b14cb8453549c98f44d43419c08f918528056d32d719113ea2b193a5121cd1642f43ffe608d556fbd826ef6ed8a2dae5313d768f3aafb69bf3aa997dc724062d271a55de4db508dde3d03eb841c0edf855f2f71960549640937e76aaace2f2a6504d3e9fce025bd4280519ebd36be655a6a20e40684acf3f99e5102a46ed94cc93eb234f6b7e140cc330eea2e4264e363374e92edce773dcc317aa6d2f2c86a95a4dee8ab96372302b808018499366e42488e4041d7f39a73b9f0616fc635a4c7682c4ca7139f2306ce74e69c44ad3ea85d250d0917fd4215de0ad96df2b0fd1eba478a4b2e36439424216b329d1d17c6a6e5bc00d66f076ab8f8645a8a15958685985f1c8f5243670ab77adbb658b93b88bc519c74e0438eef7972cd1c62e4e7e29c87a73bb5987e7245b4618c3f658738dbae315063621f529d2f1e2275054fe6f90cdd680708d7121455f47c8cdfc1935334bb87d8cdf15c7759f974cec5cf70ada49733d00bef6e63bc8edd5cb1026eb0debc266ddf153060308ccd29ffd10d8c49197d62168f50f1fc6a6805596d90525d16f216c253599d95ac5fdce57d18614f1b3674a67275ecfe6ff2ccbabf81468500b5c4e6380fe0a7bd39a02e09326983aff08345477875c9798bae58209ba965f7ecc9c62811a7b724fc846e172757d162ef58962eb89f60451cbb08c7222f38e995df677502eac94d90da5cbd825017b38845bcac518b37d1c214dd3b419e8b9c8b6f118c54013341981c250a5e6a58de43846c2f4fe38d848654c3b7cb7f39e5a0e2b4e485097d177128ccee2b1e39523de0e77ce31782aa71ae81fd74490c8e7c7fe5b824f2dc4761171a37165e98226522e208c867cea9a6c0a60b5a055dcb02b1af2c084093ec9fa04d6695dc0a1c923478e13f1d8793c8a60887dbd96752b93614b76fe2cfcecf4b24a3a52f76fae20fc04c010407a40758e68f4e49b071be9906f021c99e0b0a03f96902c2d1d134dc562770c537b92e3b07045528a6adcc819dffa2b4a24eab7a811e824de06cd871eed8fb6af4bae09731779dc272ef45ad1241e91657ed1a3b38c89a0a705659fe57fe2f34c11ee7caf509e8281297979239817e15d1c66034653e399f8343ca359fad86787aa2d7f4be8f5400e41e1a21bfcf9bc58f4ed12b9eb9b6e43952e600c5b0e180c30cef1c9183fcc2576ca53b8a489ac501afce8a05e0381f32e8c67ce434b4ec2c3041b0cbfd22390a7901b3db08e989b97c4d7aed7efaa2bcde95aba881f0de017716aea0c10f595b7ed22af32c3ecd2dc05ae153732b982334092663b24f005a7c19dcb50d3ec920858746a9d950630d44ffb2653efae1377c2bc7e2e1a4d1592262239a3ffa9f41ef08bd0b5bfce2bb76b53b9633b3d4a9cde8517cd450b2c294097d0d1b7f81ac755bd2a65ec4e548db5a7398b4970586a408f3d65ef093fb89210b1fb80537f98486769613416c55979b59ef7e035ae178b31d89457bb7826cb4f5211b5ebd68ac40c69454eb10484c19b8f5f3c043fbb8fac9fbb2809420aea764fb59552eb0ebcdc85ed1604a4d6ede12743f3fe8c39fa54275a5c37a27b50f5c46563562035f742c7afb9569f595c2e7bc8f9563e57604a856ad84a0c7cda8d8faff3490323efc5384580d00a54b25cc13ccb25df9e94f80b62e9cf57774836857b53341a69140da06e04c82e5b2fe6245ea913c44e37ceaf5b30626e38543866ff9f1335c32835293cd5eff0ded944905f63ce024a58b853ffd06a4dafdc272028fbfc35b826595ea389b2e04d7533b6281d8248c10be60f6581bca9b220d1c21f81caf7744c9a3ebb97a360ac4ce660aaf7945497b1f97100af8b8e1aae607f5cb3fe53ad3791dfb04dc88b55897d0f32ca5ce5dd97fbb9a6536f6e58925ce87e86ec4c0b785142af8b995e66ce31b917607ecf5cf244dd52329717880327bc085f4bc7eb20086284551c6c9dc9fad77fd365416e137e73ac320b48cbacfc6d5c7a1c0ef2449f700bdfbbfe9b54b6382f77564a0d1e6b377612025e0bdfbddb61f1f7496ebf8fefca9c715b75d8a7240698e59a0015995bc16181b458d74e4f9f4fa89bd1017f7e4f682e0e98756f819b71fe3a70e84795ae44201eb882912f71716aefc6a1351c3342987a89d81483e772034275e4fc2e832289527794de68ef1b4c1a6e681b9063164de299de0a353a27f5a2f00e60e7c878548f8c2ffd932272522d32465895080c143dbd4351d644ea5a6886a791982a8abfa1c099704885eb313004830ba9dcf8e3c30e108c13f6d3c4da8e4ed786383edfbca582e68b4ced550b32c28bbee2d0a8bae3a3a75de5d5ec3be8f0538dd26d4080285477ee2a4e2469d4f5609c13412a99b98d0b250ce37c339d30330af220087fd9197bf610d8f80eacea7afa71e7480d98a75966f624c55a1891cec8b8fdcc6803782581a553f8736b4742fa1dbb337600747b406ee7fd47a60d2396a8a79e1dfc6b11a5e7fb6a4670a75fc469baf82500df1a8fc0080042e4272dc08a752f502ce5e0a43dd64d0aff7ad6f41962c0d71fd1432a526109d360c101bb0723b229e44b7513e72c79a61fc3a3620dfe67c84ed1320dfad86f406d12fcfbfeb439e93b5f7d3e4dbcc291a0eee8d802e5f2960a7b79c45813343756e071985314ee52b781dabf2978c1e1c1f8debab6a1388d507b8aeca469af059ba6154ef0ce78c7fc23b337cdbe546da04b4f62ec6caaa78652269a17514b29a5060d24e5590fcf346897d8254f9854cb00f1012980d8b5844c11e7d871b72ee7e5e1682921750df55e612b8a0134daec0884065bd779dcd646a5a11b7805694c7d7cba88e952a6b73efaa17d3c7b9c2e9706dacd0edfd94bf81e5172d3e7eb4969c2879187e99e7af1dbf91785f525157340126a03580a6c388dd30ce20dac4c4e1e49a98814467f1c2ad8639e87c6d903789a6aab77449f1860cce9188e6d0c609e18a0c95e2e7f9a2c15be2401b9049f919418e6d0ab9d8da3a7d71e53031d23d4ec448158472cec5a49c8984962463856458ce99d1f639c8382785272af9b6eb44c3ed2745dab075147457a6a25f019c9eb4845c864b055b9a4330e49ec35cff1fa8a0be6a875450d908321bbbdc4a98b2fc1893101f1bec64a67c51aac0ac50b5b0e3f4268ac16adbe9c9243d06baba405309a40c2bd393b6dddd467d92beaf3a5e25a7bbffb115546592ae149b1e23faa49480829f0c614417d153bf50f8b579483519b701f38c70d48fed947a09ce65ac4ec148cf02c8c5f30130facb2661c6c7eb44de38d396f9b89f88fc172c0d84f4cabbb686349bbe42257cb645b2690cf0e3189e8bc846cdf8a18cee9876dc9e2b82b7e82ae6468e6a6c26d24e65833dee64cfafc13897237fd5232be441b64690e50379de27b66057ab1a1d5a5e66f8db5c6ebef363dd25cf2f3a9f6fbbdb3fbc39f9288262f81b946ffd4beb8f7b1c953b888b310fa1a93077f0ccea5f253bb5b08e98dec03375dc944340f43d8dba1f429ae34354dcc95b147ca0b55e2967a71a9f190d576617d5a2b8b168c2db57eb020d6127cb9775222d376cb7347a4226e1611a1613a2015ae7f32c60e24468c5b8680d1bc860302177e238d527fd91453f571993a05d4e3dcb80f1b54b4e6bdb18a0113d0952b8be468e0b01314560d6ffcb4568897ecdb6085d0c0ab0ecfaf60be63296ac3114db13f9703491779cbb74ecf4aedd9ff4081c3db943b0862d422a237676792b380cb6e3dcaa0fc5261dbfce6b0eec17acb0b9f5e1b2f84d925bae0aaae8a69bba36ef14adf8bd34b87b77a6304289097884bdddfc6200d7a04b591085a6aeb6970ad91749b3287288b22fa4e321a1c9d45fd2b8b4cad7ca753316d3041ac8ad7565abe250e16896fdb35cc60200b415baa213b67b8b5fca8435cea039ff0629f8aa3d9daeba3c51f5cb3fbaef95d921dada5c750bee8b3bb21a30af6314ba89771f009771873f6ddfc2e326e0f71d1330bd068d8229cf03fff229def3f34e545a5be20cf221e9bf6504564ba48e9d4119995f9d1f643af3a2557c552a3155efd6593b4a141e7b1fb36aa5a79910ba7c0dc7564be6157935874f26e8dec0f3d0586905a3a4d4fd11646fcdc7666073ea684ead89e45d6d530b7615e7e8017a8a6d7a2b48e1004dc23ac5b11930132dfa97cd30ba661532bf804e39f53e18fe1792d646380166786b527f857b5082d9b0e3c035135479f4e2a3a74254c0559b670ca8706bef6745ad0056dcce9b09f05e948a60cea9623003747411cb27431bde4ae7f4ab31f4731a298d08d9a3d93bc9aa0d30f527184761d18b48e62aee4f64e75de0bc81b39a602d2a0796eefc5fcb196ca73cc7adde0feae58a97230c554981be9f7fbd0e0cbdcb1bee9cd0da844705a519906bd404ad6eb819e14cd789132c95be3d15cb4fa6f54836696922304fa7c9a4342598ef6eb459cede5b293e085439f8944e7220c764962567fada2eacd3f9ac4bd3610aac38aa585e5f492f1a370226077e0182407cfc4e0066d582d5f1e750bbf621d0f840571e5fd36ec1774f9d7a53d40d09debcc727f5e722fa4dbd16ed56f3e4ab00bcfa2cf4753ba767416960d6af8386271f8982e63948b23fd91454901c8c76808f74783340b17aefafe09591a37a5bef575e7ac8413d77fcf05b88817aac6bef7a2c3c8dfd9e6231ac3a1034f7e4549778b17c1556243578d20a5a8e7dce49a0596b0d972a923aaa3c8f1f73d0edffaa5872c71f97b936e8fa819c93e14ec2cfcdb516708e9fbcf1634899363ae599ea1bf640fe50f5b85bbf94acadd6556ec57e41448d9df111f6476c75672c4b42e9363ea595c078e95b8cd217c9a6f43d79f03960def9ee23a87946550d80bd57f73eda4a79451df4531f7713fd9b292dc8bfe13d6c54f38dbdb78825ba9bcdab8234ea91a1ba4932640834056268af82c1fd24604fd6450a816970427d99c39676007575ee3de2b34f018bfe4272e43049efd78777b752749873cb1072ca9ea2eeea1e4cf461715c5c1e769d786aa959a48b9035bca00852d6c0e28b878cee9b8a9d5708c3892fe44eb1af381ee58d71a671b8deccb567b3390dd76dc332bf3c32183e8bc1c9a1aa9f92662bc06fbac8f41eed4548531e0e1d7ee8da15018d807b9106f4708219da870e95aeca6200410b1b0647dc6cf87b84a9722734dd6172e672012235cb27235a95aa42b239cb408554fa51da3ff1525e57c09aa96c24307e30c513ed8db4894f94618a9eca03b911a98f609c61559791aa4a18dfe97c01aa3f688331a2aff3bc7d79a4b5463476a597d6029157ae21aa950d12d004684c1d7a79fc3351ff11e7a709092406ddec4e6d7d24b54814c7fb35f7a0297afd0b03266fa0c4a64ed4fe2bdc158804b9940b52d3fe809a66f1d1ee1670ebc6527337b5a9a1673c6700e399f29cb3236fc746c3ac18dc08418e35736880a7946edc1499fb824518f79506ec4c1824b094b7034f68bbe63ef779a5e8e0cae2a4bac9029ef353064ae6332af635427f90234228443c4ab04f1725b73a8bf0cac0b074a583853e23dc6f49438aba43f969d383e146ddf149dc2a9c5403cbe9b39f658e1bafbdc88ca75bc264b44b23e29abbb6adf29dbccd7398fadbeb2de78f854746d723a353d1e41e70c6b0448b968ece3fd1bb265173ea42f389a5a9083d524dbd637ab4d913e6285a656df637cb55eb0e58900989a9753f128b0456cc22a2d885eae71d57dfc5b17788cdd13abc9f590ebdd2970558790df44d2da170511e176e8fb086178b3342ada9202dafcf358a198d6273fbf1844e0ee8bd5b2f6e3604ba86dde93937f0864118268c11d3921d961b7c7e2c4240d1de79c01e7f0d4b9b04f992af890ce8c8617a94704404975ce2d183db80bdb0538f02202e92cf772c8b3f4d4ddd8987621af894d294d830a067043d0ab6d787bfbabc273e3d55c5a5d812f5d027e5d3287caeef967655253d3032d00bc110f17b21c6a2752da0b6b7ca95c4310f8f13bce95f8f261cec5993d69232d400ab533ca8a0ae4e9548dfd23bbe93894d8147a460d9729de503f353eb2f06d646cecb0f404277826faa829b8cbb5d3c1c88276729a3d29f4aad4d046985ef5385583614d657a9dbed4f34ccb2a6cd2b742827cd32d0541f0586ace310294e249d1f725672a321070c79470c55408ce39fb2b9540344d317a230f859eb6c358b488411a65da10ad1643a06ca239b24497316bf8c8bbfbc11494f65bcd3dd1a9ef2525fd90551306f4a0de2450f7a9eb8ab9c390e7b4b150871667e70daeaed61edafc73502dbbe81b278992de7f4194610c6092fe07d5f9da78b8c3ceec5e25675496b0a6eb66e55af120cfad4df567440ebc17ced1d493d6b91d530b29c06c216d0e6a49ee8395091aed0fd91ff40169e0489105b6c7e795db47cd52c10956edaf3bf5685b5df838659880e134db94f7d6687800416e986e18bb478bd714a65700f8d6b905592994d19c573ab86207b92570ed2063d110091a4e4da0faa52019e2c8afb687a736f3fb3951b6448edcb1e4ce614ddbfe870a1b37cd10e4a6a1f389be973522a21eb631a849ed53e81f4dd5c03dc6132d26bde9b47088919d8e2a98e447c8b01baabbd239372c4eda0cb5fc7539ea56c67be0b67f8b3abaa18903bf5368c14c309c448646409e4c626e8b08502df81fe7d0607ad5441cf71beb366d117d297740ba65a34c64fe20e28be579caca2aa33506e0938ceb4ef1b5f3fcea00aa0caaaadd97f3e9a00a5ab2276af8544df57fec200a8e9fb996b7f91806c2411ed947c130c4d17bd95e140e42e63738769ea5715dc2c88272353d822c9f20c6214d225710326d7dad1aa6811c61c8857df18307a3f473f3e3674dbd75fec0a7052a6d10514b9a2028223b74a72f5424a7a492e159888b164483482856e01ca674994f30608d34a4d3fdbdb5fba91b212d3a7f516d72a79d659222bf22203cdea6ff5756cade1c163076c2e95b7c3ad29e1623be67e118eff0409d395bd5e70df8ce4b93a4841f56c4823f0f460ffb3b8d207d4eeabb5572c4375dbf60a334a6fc2f2dfbee9f67df46553c788d53b3aba207ed2c7cddb17c4b741abfe6657b2da25250e0d17b6c195d9f3bc95bd609078e7f95709846e66139017ca8ecac55668aa9c366f84285909c73356cd766dc7c4044e6e9239e33c4de4f007d84a871279ae8780db3af1d568c3cf6eb9d6b3018706b662c41b6cf85d74e6b7dc59bdf2c06175a831fed86a9598f942e53ccba3d08f63411cb0fe49bd69f7ff890ea10a809f9d296333bd0dca656a94624fcf03b1c911da6988d60cb073c95ee0d9a483dff75dbdff193cddaa0948fafde2ae81f202f9152b8d5a096f402c53f7ce8ad2050ae60a4e10ab70a2bd00f5ad7d3fd2596fbfd9c37bd14cec7cc3efbb2861f0d5f9c0df8e8f50cb2e919a4036f65d645a4b356fefeccbee1a51d153670e2a3c19591b35325bd9d7a75a8fc2b3a3217bfea8e843299c976a40beff8be3869f1d65d8fbad962932731dff76b04cc0355f9d600c8c301a5e3727542ff9fefe961028470e914ca14ed1a53e2d7c63abc4279049295022addf465d8fe0917f2b6e48a2486d8263ce13aac97ee67bdc95dc7681816a4d4e69d29e708e11de971e118d0833bccf0219dc3b6629711326ca05df90e97d775b14e6be2ff7d0c6cfa4c10ff38daff8bc47d10fc95293031899062eef200e82bb9fc1d6f1aee88d103ff232f0ad11b6cd36d892ed56b7b96ffb87cbc7fc784d765d43a7a3a64ca05bde27b64bb79b5a1ff23310b98e131e5ad3c3e67cd5c29c989bdf60510c82dcbaa6239bdb6adb1ec4dba365755eff5e0cb548fe9a9829251262edd59c445bd41ced16b1a037650a29d7def499da8fff29316f945891e5c180ce45d8590eda142ec4b56cacb75f72b06a2fcf41ee0bd3723053d44758edd6a08448a4f97720372e4169fd4232996bfda5996d9c6ccabe65083361cf91d5cbde71036be0d37f3fe207ababe455be7ba1c8f2705a183dfcffe4ffce9de3e0d9b00c28621fab552077d947f2d8bb0eb20c17510e2f7bbe690e3f2b2135d9d3011e39cdacbf844e79b8bb27495b6bd2125fd32b0c83a10699c891796b3b82497ffc26fb45c2e0cce04693dc7910e794d3438e7925b8bc677c9202d86b19ce01522d87ebd5ea386f3566b87f21588186c3a9c135697023d814d00db9fec7c6838eb9c7d0e14149ffba2b3ff23778535ef740b97ea774a8510a9cc811da25ff93c3757fa772be25d6bd5f736a9570604013c4b71b49ce9e84f9af29b6ae7444486035562e8b6f6d2a5f5685574d048c61494d6bf1f95b238aa6154ca5813b78786606c52a254be694c6415c984af7650a47c7e7cd55cc86f74aa5719fded4a5852f81df5e16bad7a9ccf7ae04722a39d162f708661f6e032db5c1cff20c0e7be0523c44327ddc28076acbfb54e401aecb67fe2a725991b9eabcb1ffae368788f66af2502804c667004e3a68965bd0612a11f5786a21bedd609bb01f8f49e315a8d718aea15b1e8984c35cec21a5aa410e4e878c1941b733997ea5e62d485a9e9b1e7ae5e7860d7ed6347aea68ac1f2456600927a0c906a0370bddede8a4585124ae4213e7f78b3d085b8d4d2e7de0200d26933162e9acbbb4f7e95ac185d965e184e73d9e6b03ea006dd11d5e6ee3b52e922b4d1528dbe1e018e0e4894feb3138cb2792fb7c8951b9070f8ae075d0a1983d03e723496ebdf276fd27908ccfeedaee3e99e2515fc5da968566241f29805c98982d79dda2286ba5cfc4c2011d39c7a64ef34fdba6f49d8725c72efd45066c3f6a7c3d3393516d5883b10fac26c8f262f3eaa546f4ac2784d47154e39d42f28d5d639f4316806916d210a164d79297f96d550cf12cf4cf0116d8b2e2a9040ccf4e1759384c182d27c8065954fa24ad3ccb0211ca1aef0619f0359918c1e0d7f0c3dae92f9667d0ab81772775d5df37576094e851f811e276fd6e95740e207cbb36393977faf317042274ba1b5b564c65395fa0680447a5976b54dd0255e1d73e051853c648c5a881a421a5957f6fc529232906f57172bc8ccef5acb6c8178e9d2169681f4165c0a32cbdf96fe1a5594d50467f7a80cea35dcf5771b9e4066750bd533cbb106c3858b3379ae05700d21dd464c1ecd8a95052330bded5ae03264428c324f2aecad79a546c9e7a6f74d522be813c93b1d934205f9833eba773c1fa9d02c43fc6c89ed6aab556e49546f26ac5943b9d715746c6c01b0e2f0a506411e4d01ec1adca70e7aefdcec89438d2e27ae3e5f2e32f553cbb23aeb7be8e943849a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基础</title>
    <link href="/2021/03/24/C++%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/03/24/C++%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="c-中的smart-pointer四个智能指针简单介绍"><a href="#c-中的smart-pointer四个智能指针简单介绍" class="headerlink" title="c++中的smart pointer四个智能指针简单介绍"></a>c++中的smart pointer四个智能指针简单介绍</h2><ul><li>什么是智能指针?<br>它是一种可以像指针一样使用的值，但提供了自动内存管理的附加功能：当指针不再使用时，它指向的内存被释放（请参阅维基百科上更详细的定义）。</li><li>我什么时候应该使用智能指针呢 ?<br>在代码中涉及跟踪一块内存的所有权，分配或取消分配； 使用智能指针通常可以省掉这些操作。</li><li>但是我应该在哪些情况下使用哪个智能指针呢？<br>当你不打算对同一对象持有多个引用时，请使用<code>std :: unique_ptr</code>。 例如，将它用作指向内存的指针，该指针在进入某个域时被分配，并在退出该域时被解除分配。<br>当你想从多个地方引用你的对象， 并且不希望在所有这些引用都消失之前释放它，使用<code>std :: shared_ptr</code>。<br>Use std::weak_ptr when you do want to refer to your object from multiple places - for those references for which it’s ok to ignore and deallocate (so they’ll just note the object is gone when you try to dereference).<br>当你想从多个地方引用你的对象，这些引用忽略并且解除分配都ok(当你试图解引用时，他们会注意到对象已被销毁)，使用<code>std :: weak_ptr</code>。</li></ul><p>参考:<a href="https://blog.csdn.net/y601500359/article/details/105297348">https://blog.csdn.net/y601500359/article/details/105297348</a></p><p>参考:<a href="https://blog.csdn.net/ftell/article/details/80395597">https://blog.csdn.net/ftell/article/details/80395597</a></p><h3 id="智能指针的内存泄漏如何解决"><a href="#智能指针的内存泄漏如何解决" class="headerlink" title="智能指针的内存泄漏如何解决"></a>智能指针的内存泄漏如何解决</h3><p>为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p><h2 id="C-中析构函数为什么要求是虚的"><a href="#C-中析构函数为什么要求是虚的" class="headerlink" title="C++ 中析构函数为什么要求是虚的"></a>C++ 中析构函数为什么要求是虚的</h2><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p><p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p><p>参考:<a href="https://blog.csdn.net/linraise/article/details/8913105">https://blog.csdn.net/linraise/article/details/8913105</a></p><p>参考:<a href="https://blog.csdn.net/qq_42247231/article/details/105109709">https://blog.csdn.net/qq_42247231/article/details/105109709</a></p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</p><p>简单讲：回调函数是由别人的函数执行时调用你实现的函数。</p><blockquote><p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</p></blockquote><p>参考:<a href="https://www.runoob.com/cprogramming/c-fun-pointer-callback.html">https://www.runoob.com/cprogramming/c-fun-pointer-callback.html</a></p><h2 id="C-中析构函数的作用"><a href="#C-中析构函数的作用" class="headerlink" title="C++中析构函数的作用"></a>C++中析构函数的作用</h2><p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</p><p>析构函数名也应与类名相同，只是在函数名前面加一个位取反符<del>，例如</del>stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</p><p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</p><p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</p><p>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</p><h2 id="重载和覆盖"><a href="#重载和覆盖" class="headerlink" title="重载和覆盖"></a>重载和覆盖</h2><p>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中<br>重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</p><h2 id="虚函数和多态"><a href="#虚函数和多态" class="headerlink" title="虚函数和多态"></a>虚函数和多态</h2><p>多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。</p><p>虚函数的实现：在有虚函数的类中，对象的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p><p><img src="311436_1552470920741_7D40CEF3951A10F626301148E06D89DA" alt="img"></p><h2 id="右值引用、移动语义和完美转发"><a href="#右值引用、移动语义和完美转发" class="headerlink" title="右值引用、移动语义和完美转发"></a>右值引用、移动语义和完美转发</h2><p><strong>讲的非常非常详细 很牛逼</strong></p><p><a href="https://www.jianshu.com/p/d19fc8447eaa">https://www.jianshu.com/p/d19fc8447eaa</a> </p><h2 id="常量表达式-constexpr"><a href="#常量表达式-constexpr" class="headerlink" title="常量表达式(constexpr)"></a>常量表达式(constexpr)</h2><ul><li>在编译期就可以计算出结果的表达式。</li><li>对constexpr函数的基本要求：<ul><li>常量表达式函数必须有返回值（不可以是void函数）常量表达式函数体中只能有一条语句，且该语句必须是return语句。(可以使用?:、递归)</li></ul></li><li>return语句中，不能使用非常量表达式的变量、函数，且return的表达式也要是常量表达式</li><li>常量表达式函数在使用前，必须有定义。（普通函数在被调用前只要有函数声明就够了，不一定有定义）</li><li>与const的本质区别:<ul><li>const主要用于表达“对接口的写权限控制”</li><li>constexpr的主要功能则是让更多的运算可以在编译期完成，并能保证表达式在语义上是类型安全的。</li></ul></li></ul><h2 id="malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"><a href="#malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？" class="headerlink" title="malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"></a>malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？</h2><p>Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。</p><p>当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。</p><p>Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。</p><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>进程向 OS 申请和释放地址空间的接口 sbrk/mmap/munmap 都是系统调用，频繁调用系统调用都比较消耗系统资源的。并且， mmap 申请的内存被 munmap 后，重新申请会产生更多的缺页中断。例如使用 mmap 分配 1M 空间，第一次调用产生了大量缺页中断 (1M/4K 次 ) ，当munmap 后再次分配 1M 空间，会再次产生大量缺页中断。缺页中断是内核行为，会导致内核态CPU消耗较大。另外，如果使用 mmap 分配小内存，会导致地址空间的分片更多，内核的管理负担更大。</p><p>同时堆是一个连续空间，并且堆内碎片由于没有归还 OS ，如果可重用碎片，再次访问该内存很可能不需产生任何系统调用和缺页中断，这将大大降低 CPU 的消耗。 因此， glibc 的 malloc 实现中，充分考虑了 sbrk 和 mmap 行为上的差异及优缺点，默认分配大块内存 (128k) 才使用 mmap 获得地址空间，也可通过 mallopt(M_MMAP_THRESHOLD, <SIZE>) 来修改这个临界值。</p><h2 id="C-STL-的内存优化"><a href="#C-STL-的内存优化" class="headerlink" title="C++ STL 的内存优化"></a>C++ STL 的内存优化</h2><p>1）二级配置器结构<br>STL内存管理使用二级内存配置器。<br>1、第一级配置器<br>第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。<br>一级空间配置器分配的是大于128字节的空间<br>如果分配不成功，调用句柄释放一部分内存<br>如果还不能分配成功，抛出异常<br>2、第二级配置器<br>在STL的第二级配置器中多了一些机制，避免太多小区块造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。<br>3、分配原则<br>如果要分配的区块大于128bytes，则移交给第一级配置器处理。<br>如果要分配的区块小于128bytes，则以内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。<br>当用户申请的空间小于128字节时，将字节数扩展到8的倍数，然后在自由链表中查找对应大小的子链表<br>如果在自由链表查找不到或者块数不够，则向内存池进行申请，一般一次申请20块<br>如果内存池空间足够，则取出内存<br>如果不够分配20块，则分配最多的块数给自由链表，并且更新每次申请的块数<br>如果一块都无法提供，则把剩余的内存挂到自由链表，然后向系统heap申请空间，如果申请失败，则看看自由链表还有没有可用的块，如果也没有，则最后调用一级空间配置器<br>2）二级内存池<br>二级内存池采用了16个空闲链表，这里的16个空闲链表分别管理大小为8、16、24……120、128的数据块。这里空闲链表节点的设计十分巧妙，这里用了一个联合体既可以表示下一个空闲数据块（存在于空闲链表中）的地址，也可以表示已经被用户使用的数据块（不存在空闲链表中）的地址。</p><p><img src="970829_1555246716341_19203EAD1152E0317EE9B5F6BFE090C6" alt="img"><br>1、空间配置函数allocate<br>首先先要检查申请空间的大小，如果大于128字节就调用第一级配置器，小于128字节就检查对应的空闲链表，如果该空闲链表中有可用数据块，则直接拿来用（拿取空闲链表中的第一个可用数据块，然后把该空闲链表的地址设置为该数据块指向的下一个地址），如果没有可用数据块，则调用refill重新填充空间。<br>2、空间释放函数deallocate<br>首先先要检查释放数据块的大小，如果大于128字节就调用第一级配置器，小于128字节则根据数据块的大小来判断回收后的空间会被插入到哪个空闲链表。<br>3、重新填充空闲链表refill<br>在用allocate配置空间时，如果空闲链表中没有可用数据块，就会调用refill来重新填充空间，新的空间取自内存池。缺省取20个数据块，如果内存池空间不足，那么能取多少个节点就取多少个。<br>从内存池取空间给空闲链表用是chunk_alloc的工作，首先根据end_free-start_free来判断内存池中的剩余空间是否足以调出nobjs个大小为size的数据块出去，如果内存连一个数据块的空间都无法供应，需要用malloc取堆中申请内存。<br>假如山穷水尽，整个系统的堆空间都不够用了，malloc失败，那么chunk_alloc会从空闲链表中找是否有大的数据块，然后将该数据块的空间分给内存池（这个数据块会从链表中去除）。<br>3、总结：</p><ol><li><p>使用allocate向内存池请求size大小的内存空间，如果需要请求的内存大小大于128bytes，直接使用malloc。</p></li><li><p>如果需要的内存大小小于128bytes，allocate根据size找到最适合的自由链表。<br>a. 如果链表不为空，返回第一个node，链表头改为第二个node。<br>b. 如果链表为空，使用blockAlloc请求分配node。</p><p>​    x. 如果内存池中有大于一个node的空间，分配竟可能多的node(但是最多20个)，将一个node返回，其他的node添加到链表中。<br>​    y. 如果内存池只有一个node的空间，直接返回给用户。<br>​    z. 若果如果连一个node都没有，再次向操作系统请求分配内存。</p><p>​        ①分配成功，再次进行b过程。<br>​        ②分配失败，循环各个自由链表，寻找空间。<br>​            I. 找到空间，再次进行过程b。<br>​            II. 找不到空间，抛出异常。</p><p>3.用户调用deallocate释放内存空间，如果要求释放的内存空间大于128bytes，直接调用free。</p><p>4.否则按照其大小找到合适的自由链表，并将其插入</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2021/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="线程和进程的区别是什么？"><a href="#线程和进程的区别是什么？" class="headerlink" title="线程和进程的区别是什么？"></a>线程和进程的区别是什么？</h2><p>看了一遍排在前面的答案，类似”<strong>进程是资源分配的最小单位，线程是CPU调度的最小单位“</strong>这样的回答感觉太抽象，都不太容易让人理解。</p><p>做个简单的比喻：进程=火车，线程=车厢</p><ul><li>线程在进程下行进（单纯的车厢无法运行）</li><li>一个进程可以包含多个线程（一辆火车可以有多个车厢）</li><li>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</li><li>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</li><li>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</li><li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</li><li>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）</li><li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－”互斥锁”</li><li>进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</li></ul><h2 id="os-signal-信号"><a href="#os-signal-信号" class="headerlink" title="os/signal - 信号"></a>os/signal - 信号</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>信号是事件发生时对进程的通知机制。有时也称之为软件中断。信号与硬件中断的相似之处在于打断了程序执行的正常流程，大多数情况下，无法预测信号到达的精确时间。</p><p>因为一个具有合适权限的进程可以向另一个进程发送信号，这可以称为进程间的一种同步技术。当然，进程也可以向自身发送信号。然而，发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下。</p><ul><li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令（除 0，引用无法访问的内存区域）。</li><li>用户键入了能够产生信号的终端特殊字符。如中断字符（通常是 Control-C）、暂停字符（通常是 Control-Z）。</li><li>发生了软件事件。如调整了终端窗口大小，定时器到期等。</li></ul><p>针对每个信号，都定义了一个唯一的（小）整数，从 1 开始顺序展开。系统会用相应常量表示。Linux 中，1-31 为标准信号；32-64 为实时信号（通过 <code>kill -l</code> 可以查看）。</p><p>信号达到后，进程视具体信号执行如下默认操作之一。</p><ul><li>忽略信号，也就是内核将信号丢弃，信号对进程不产生任何影响。</li><li>终止（杀死）进程。</li><li>产生 coredump 文件，同时进程终止。</li><li>暂停（Stop）进程的执行。</li><li>恢复进程执行。</li></ul><p>当然，对于有些信号，程序是可以改变默认行为的，这也就是 <code>os/signal</code> 包的用途。</p><p>兼容性问题：信号的概念来自于 Unix-like 系统。Windows 下只支持 os.SIGINT 信号。</p><h2 id="进程间的通信方式：共享内存"><a href="#进程间的通信方式：共享内存" class="headerlink" title="进程间的通信方式：共享内存"></a>进程间的通信方式：共享内存</h2><p>共享内存指 (shared memory)在多处理器的计算机系统中，可以被不同中央处理器（CPU）访问的大容量内存。由于多个CPU需要快速访问存储器，这样就要对存储器进行缓存（Cache）。任何一个缓存的数据被更新后，由于其他处理器也可能要存取，共享内存就需要立即更新，否则不同的处理器可能用到不同的数据。共享内存是 Unix下的多进程之间的通信方法 ,这种方法通常用于一个程序的多进程间通信，实际上多个程序间也可以通过共享内存来传递信息。</p><h3 id="共享内存概述"><a href="#共享内存概述" class="headerlink" title="共享内存概述"></a>共享内存概述</h3><p>共享内存是进程间通信中最简单的方式之一。共享内存允许两个或更多进程访问同一块内存，就如同 malloc() 函数向不同进程返回了指向同一个物理内存区域的指针。当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。</p><p><img src="v2-195b0cf5f101ed8c11910fea9b77559e_720w.jpg" alt="img"></p><p>上图描述的内容一样，共享内存实际上就是进程通过调用shmget（Shared Memory GET 获取共享内存）来分配一个共享内存块，然后每个进程通过shmat（Shared Memory Attach 绑定到共享内存块），将进程的逻辑虚拟地址空间指向共享内存块中。 随后需要访问这个共享内存块的进程都必须将这个共享内存绑定到自己的地址空间中去。当一个进程往一个共享内存快中写入了数据，共享这个内存区域的所有进程就可用都看到其中的内容。</p><p><strong>共享内存的特点：</strong></p><ol><li>共享内存是进程间共享数据的一种最快的方法。一个进程向共享的内存区域写入了数据，共享这个内存区域的所有进程就可以立刻看到其中的内容。</li><li>使用共享内存要注意的是多个进程之间对一个给定存储区访问的互斥。若一个进程正在向共享内存区写数据，则在它做完这一步操作前，别的进程不应当去读、写这些数据。</li></ol><h3 id="共享内存的通信"><a href="#共享内存的通信" class="headerlink" title="共享内存的通信"></a><strong>共享内存的通信</strong></h3><p>因为所有进程共享同一块内存，共享内存在各种进程间通信方式中具有最高的效率。访问共享内存区域和访问进程独有的内存区域一样快，并不需要通过系统调用或者其它需要切入内核的过程来完成。同时它也避免了对数据的各种不必要的复制。<br>因为系统内核没有对访问共享内存进行同步，您必须提供自己的同步措施。例如，在数据被写入之前不允许进程从共享内存中读取信息、不允许两个进程同时向同一个共享内存地址写入数据等。解决这些问题的常用方法是通过使用信号量进行同步。</p><h3 id="共享内存的内存模型"><a href="#共享内存的内存模型" class="headerlink" title="共享内存的内存模型"></a><strong>共享内存的内存模型</strong></h3><p>要使用一块共享内存，进程必须首先分配它。随后需要访问这个共享内存块的每一个进程都必须将这个共享内存绑定到自己的地址空间中。当完成通信之后，所有进程都将脱离共享内存，并且由一个进程释放该共享内存块。理解 Linux 系统内存模型可以有助于解释这个绑定的过程。在 Linux 系统中，每个进程的虚拟内存是被分为许多页面的。这些内存页面中包含了实际的数据。每个进程都会维护一个从内存地址到虚拟内存页面之间的映射关系。尽管每个进程都有自己的内存地址，不同的进程可以同时将同一个内存页面映射到自己的地址空间中，从而达到共享内存的目的。<br>分配一个新的共享内存块会创建新的内存页面。因为所有进程都希望共享对同一块内存的访问，只应由一个进程创建一块新的共享内存。再次分配一块已经存在的内存块不会创建新的页面，而只是会返回一个标识该内存块的标识符。一个进程如需使用这个共享内存块，则首先需要将它绑定到自己的地址空间中。这样会创建一个从进程本身虚拟地址到共享页面的映射关系。当对共享内存的使用结束之后，这个映射关系将被删除。当再也没有进程需要使用这个共享内存块的时候，必须有一个（且只能是一个）进程负责释放这个被共享的内存页面。</p><h3 id="进程间通信和线程间通信的几种方式"><a href="#进程间通信和线程间通信的几种方式" class="headerlink" title="进程间通信和线程间通信的几种方式"></a>进程间通信和线程间通信的几种方式</h3><p><a href="https://www.cnblogs.com/fanguangdexiaoyuer/p/10834737.html">参考</a></p><h2 id="exit和exit的区别"><a href="#exit和exit的区别" class="headerlink" title="_exit和exit的区别"></a>_exit和exit的区别</h2><p>转载：<a href="https://blog.csdn.net/goodlixueyong/article/details/6011021">点这里</a>和<a href="https://www.cnblogs.com/mickole/p/3186606.html">这里</a></p><h2 id="fork与vfork理解"><a href="#fork与vfork理解" class="headerlink" title="fork与vfork理解"></a>fork与vfork理解</h2><table><thead><tr><th>系统调用</th><th>描述</th></tr></thead><tbody><tr><td>fork</td><td>fork创造的子进程是父进程的完整副本，复制了父亲进程的资源，包括内存的内容task_struct内容</td></tr><tr><td>vfork</td><td>vfork创建的子进程与父进程共享数据段,而且由vfork()创建的子进程将先于父进程运行</td></tr><tr><td>clone</td><td>Linux上创建线程一般使用的是pthread库 实际上linux也给我们提供了创建线程的系统调用，就是clone</td></tr></tbody></table><h3 id="再理解"><a href="#再理解" class="headerlink" title="再理解"></a>再理解</h3><p>为什么会有vfork，因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址空间，并且拷贝父进程的资源，而往往在子进程中会执行exec 调用，这样，前面的拷贝工作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中运行，所以子进程不能进行写操作，并且在儿子 霸占”着老子的房子时候，要委屈老子一下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相 于儿子买了自己的房子了，这时候就相于分家了。</p><h3 id="再再理解"><a href="#再再理解" class="headerlink" title="再再理解"></a>再再理解</h3><p>fork和vfork的区别：</p><ol><li><p>fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段</p></li><li><p>fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。</p></li><li><p>vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。</p></li><li><p>写时复制,当需要改变共享数据段中变量的值，则拷贝父进程。</p></li></ol><h3 id="再再再理解"><a href="#再再再理解" class="headerlink" title="再再再理解"></a>再再再理解</h3><p><a href="https://coolshell.cn/articles/7965.html">一个fork的面试题</a></p><h2 id="操作系统中的页表寻址"><a href="#操作系统中的页表寻址" class="headerlink" title="操作系统中的页表寻址"></a>操作系统中的页表寻址</h2><p>页式内存管理，<strong>内存分成固定长度的一个个页片</strong>。<strong>操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表</strong>，<strong>页表的内容就是该进程的虚拟地址到物理地址的一个映射</strong>。<strong>页表中的每一项都记录了这个页的基地址。通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址，偏移的长度由逻辑地址的低位部分决定</strong>。一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。</p><p>Linux最初的两级页表机制：</p><p>两级分页机制将32位的虚拟空间分成三段，低十二位表示页内偏移，高20分成两段分别表示两级页表的偏移。</p><ul><li>PGD(Page Global Directory): 最高10位，全局页目录表索引</li><li>PTE(Page Table Entry)：中间10位，页表入口索引</li></ul><p>当在进行地址转换时，结合在CR3寄存器中存放的页目录(page directory, PGD)的这一页的物理地址，再加上从虚拟地址中抽出高10位叫做页目录表项(内核也称这为pgd)的部分作为偏移, 即定位到可以描述该地址的pgd；从该pgd中可以获取可以描述该地址的页表的物理地址，再加上从虚拟地址中抽取中间10位作为偏移, 即定位到可以描述该地址的pte；在这个pte中即可获取该地址对应的页的物理地址, 加上从虚拟地址中抽取的最后12位，即形成该页的页内偏移, 即可最终完成从虚拟地址到物理地址的转换。从上述过程中，可以看出，对虚拟地址的分级解析过程，实际上就是不断深入页表层次，逐渐定位到最终地址的过程，所以这一过程被叫做page talbe walk。</p><p>Linux的三级页表机制：</p><p>当X86引入物理地址扩展(Pisycal Addrress Extension, PAE)后，可以支持大于4G的物理内存(36位），但虚拟地址依然是32位，原先的页表项不适用，它实际多4 bytes被扩充到8 bytes，这意味着，<strong>每一页现在能存放的pte数目从1024变成512了</strong>(4k/8)。相应地，页表层级发生了变化，Linus新增加了一个层级，叫做页中间目录(page middle directory, PMD), 变成：</p><p>字段 描述 位数</p><p>cr3 指向一个PDPT crs寄存器存储</p><p>PGD 指向PDPT中4个项中的一个 位31~30</p><p>PMD 指向页目录中512项中的一个 位29~21</p><p>PTE 指向页表中512项中的一个 位20~12</p><p>page offset 4KB页中的偏移 位11~0</p><p>现在就同时存在2级页表和3级页表，在代码管理上肯定不方便。巧妙的是，Linux采取了一种抽象方法：所有架构全部使用3级页表: 即PGD -&gt; PMD -&gt; PTE。那只使用2级页表(如非PAE的X86)怎么办？</p><p>办法是针对使用2级页表的架构，把PMD抽象掉，即虚设一个PMD表项。这样在page table walk过程中，PGD本直接指向PTE的，现在不了，指向一个虚拟的PMD，然后再由PMD指向PTE。这种抽象保持了代码结构的统一。</p><p>Linux的四级页表机制：</p><p>硬件在发展，3级页表很快又捉襟见肘了，原因是64位CPU出现了, 比如X86_64， 它的硬件是实实在在支持4级页表的。它支持48位的虚拟地址空间1。如下：</p><p>字段 描述 位数</p><p>PML4 指向一个PDPT 位47~39</p><p>PGD 指向PDPT中4个项中的一个 位38~30</p><p>PMD 指向页目录中512项中的一个 位29~21</p><p>PTE 指向页表中512项中的一个 位20~12</p><p>page offset 4KB页中的偏移 位11~0</p><p>Linux内核针为使用原来的3级列表(PGD-&gt;PMD-&gt;PTE)，做了折衷。即采用一个唯一的，共享的顶级层次，叫PML4。这个PML4没有编码在地址中，这样就能套用原来的3级列表方案了。不过代价就是，由于只有唯一的PML4, 寻址空间被局限在(239=)512G, 而本来PML4段有9位, 可以支持512个PML4表项的。现在为了使用3级列表方案，只能限制使用一个， 512G的空间很快就又不够用了，解决方案呼之欲出。</p><p>在2004年10月，当时的X86_64架构代码的维护者Andi Kleen提交了一个叫做4level page tables for Linux的PATCH系列，为Linux内核带来了4级页表的支持。在他的解决方案中，不出意料地，按照X86_64规范，新增了一个PML4的层级, 在这种解决方案中，X86_64拥一个有512条目的PML4, 512条目的PGD, 512条目的PMD, 512条目的PTE。对于仍使用3级目录的架构来说，它们依然拥有一个虚拟的PML4,相关的代码会在编译时被优化掉。 这样，就把Linux内核的3级列表扩充为4级列表。这系列PATCH工作得不错，不久被纳入Andrew Morton的-mm树接受测试。不出意外的话，它将在v2.6.11版本中释出。但是，另一个知名开发者Nick Piggin提出了一些看法，他认为Andi的Patch很不错，不过他认为最好还是把PGD作为第一级目录，把新增加的层次放在中间，并给出了他自己的Patch:alternate 4-level page tables patches。Andi更想保持自己的PATCH, 他认为Nick不过是玩了改名的游戏，而且他的PATCH经过测试很稳定，快被合并到主线了，不宜再折腾。不过Linus却表达了对Nick Piggin的支持，理由是Nick的做法conceptually least intrusive。毕竟作为Linux的扛把子，稳定对于Linus来说意义重大。最终，不意外地，最后Nick Piggin的PATCH在v2.6.11版本中被合并入主线。在这种方案中，4级页表分别是：PGD -&gt; PUD -&gt; PMD -&gt; PTE。</p><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/bb5f2124be17">五级页表</a></li><li><a href="https://www.cnblogs.com/CreateMyself/p/13167467.html">虚拟内存页表</a></li></ul><h2 id="线程同步-条件变量"><a href="#线程同步-条件变量" class="headerlink" title="线程同步-条件变量"></a>线程同步-条件变量</h2><p>与互斥锁不同，<strong>条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止</strong>。<strong>通常条件变量和互斥锁同时使用。</strong></p><p>条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）。</p><p>条件的检测是在互斥锁的保护下进行的。如果一个条件为假，一个线程自动阻塞，并释放等待状态改变的互斥锁。如果另一个线程改变了条件，它发信号给关联的条件变量，唤醒一个或多个等待它的线程，重新获得互斥锁，重新评价条件。如果两进程共享可读写的内存，条件变量可以被用来实现这两进程间的线程同步。</p><h4 id="条件变量与互斥锁、信号量的区别"><a href="#条件变量与互斥锁、信号量的区别" class="headerlink" title="条件变量与互斥锁、信号量的区别"></a><strong>条件变量与互斥锁、信号量的区别</strong></h4><p>​    1.互斥锁必须总是由给它上锁的线程解锁，信号量的挂出即不必由执行过它的等待操作的同一进程执行。一个线程可以等待某个给定信号灯，而另一个线程可以挂出该信号灯。</p><p>​    2.互斥锁要么锁住，要么被解开（二值状态，类型二值信号量）。</p><p>​    3.由于信号量有一个与之关联的状态（它的计数值），信号量挂出操作总是被记住。然而当向一个条件变量发送信号时，如果没有线程等待在该条件变量上，那么该信号将丢失。</p><p>​    4.互斥锁是为了上锁而设计的，条件变量是为了等待而设计的，信号灯即可用于上锁，也可用于等待，因而可能导致更多的开销和更高的复杂性。</p><p>参考:<a href="https://punmy.cn/2018/06/07/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition%20Variables%EF%BC%89.html">点俺，俺很棒</a></p><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><p>1）进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。</p><p>2）进程有独立的系统资源，而同一进程内的线程共享进程的大部分系统资源,包括堆、代码段、数据段，每个线程只拥有一些在运行中必不可少的私有属性，比如tcb,线程Id,栈、寄存器。</p><p>3）一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也死掉。</p><p>4）进程在创建、切换和销毁时开销比较大，而线程比较小。进程创建的时候需要分配系统资源，而销毁的的时候需要释放系统资源。进程切换需要分两步：切换页目录、刷新TLB以使用新的地址空间；切换内核栈和硬件上下文（寄存器）；而同一进程的线程间逻辑地址空间是一样的，不需要切换页目录、刷新TLB。</p><p>5）进程间通信比较复杂，而同一进程的线程由于共享代码段和数据段，所以通信比较容易。</p><h2 id="Linux的4种锁机制"><a href="#Linux的4种锁机制" class="headerlink" title="Linux的4种锁机制"></a>Linux的4种锁机制</h2><h3 id="互斥锁："><a href="#互斥锁：" class="headerlink" title="互斥锁："></a>互斥锁：</h3><p>mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒</p><h3 id="读写锁："><a href="#读写锁：" class="headerlink" title="读写锁："></a>读写锁：</h3><p>rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</p><h3 id="自旋锁："><a href="#自旋锁：" class="headerlink" title="自旋锁："></a>自旋锁：</h3><p>spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。</p><h3 id="再分析"><a href="#再分析" class="headerlink" title="再分析"></a>再分析</h3><p><strong>spin_lock用于阻止在不同CPU上的执行单元对共享资源的同时访问以及不同进程上下文互相抢占导致的对共享资源的非同步访问，而中断失效和软中断失效却是为了阻止在同一CPU上软中断或中断对共享资源的非同步访问。</strong></p><h3 id="自旋锁使用及注意事项"><a href="#自旋锁使用及注意事项" class="headerlink" title="自旋锁使用及注意事项"></a>自旋锁使用及注意事项</h3><p>自旋锁的注意事项：</p><ol><li><p>自旋锁使CPU处于忙等状态，因此临界区执行时间应该尽量短；</p></li><li><p>自旋锁是不可重入的；</p></li><li><p>自旋锁保护的临界区不应该有睡眠操作：</p><p>1）对于开中断的自旋锁来说，睡眠操作可能发生如下两种情况：<br> a. 死锁：任务A获得自旋锁之后睡眠，接着又发生了中断，而中断处理程序内部又打算获取同一个自旋锁，则此时会发生自死锁 —— 自旋锁是不可重入的。<br> b. CPU浪费：倘若中断处理程序内部没有获取同一个自旋锁的操作，则理论上可以产生调度。假设进程B打算获取CPU的控制权，但由于此时是关抢占的（因为进程A还没有解自旋锁，此时依旧处于自旋锁的临界区中），导致进程B无法运行。也就是说CPU将无法运行任何程序，一直处于无事可做的状态，造成CPU的浪费。</p><p>2）对于顺带关中断的自旋锁来说，显而易见在临界区内使不能睡眠的，因为唤醒一个睡眠的进程依赖于调度器，而调度器是通过时钟中断来判断合适唤醒进程的，倘若在关闭中断的时候进程睡眠，则调度器将再也无法收到时钟中断（因为开中断的操作也是由该进程控制的），从而永远都无法唤醒睡眠的进程。也就是说该进程将处于睡死状态。</p></li></ol><p>简单来说，自旋锁的初衷就是：在短期间内进行轻量级的锁定。一个被争用的自旋锁使得请求它的线程在等待锁重新可用的期间进行自旋(特别浪费处理器时间)，所以自旋锁不应该被持有时间过长。如果需要长时间锁定的话, 最好使用信号量。</p><h3 id="RCU："><a href="#RCU：" class="headerlink" title="RCU："></a>RCU：</h3><p>即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。</p><h3 id="信号量-互斥体和自旋锁的区别"><a href="#信号量-互斥体和自旋锁的区别" class="headerlink" title="信号量/互斥体和自旋锁的区别"></a>信号量/互斥体和自旋锁的区别</h3><p>信号量/互斥体允许进程睡眠属于睡眠锁，自旋锁则不允许调用者睡眠，而是让其循环等待，所以有以下区别应用 :</p><ol><li>信号量和读写信号量适合于保持时间较长的情况，它们会导致调用者睡眠，因而自旋锁适合于保持时间非常短的情况</li><li>自旋锁可以用于中断，不能用于进程上下文(会引起死锁)。而信号量不允许使用在中断中，而可以用于进程上下文</li><li>自旋锁保持期间是抢占失效的，自旋锁被持有时，内核不能被抢占，而信号量和读写信号量保持期间是可以被抢占的</li></ol><p>另外需要注意的是:</p><ol><li>信号量锁保护的临界区可包含可能引起阻塞的代码，而自旋锁则绝对要避免用来保护包含这样代码的临界区，因为阻塞意味着要进行进程的切换，如果进程被切换出去后，另一进程企图获取本自旋锁，死锁就会发生。</li><li>在你占用信号量的同时不能占用自旋锁，因为在你等待信号量时可能会睡眠，而在持有自旋锁时是不允许睡眠的。</li></ol><h3 id="信号量和互斥体之间的区别"><a href="#信号量和互斥体之间的区别" class="headerlink" title="信号量和互斥体之间的区别"></a>信号量和互斥体之间的区别</h3><p>概念上的区别：<br> 信号量：是进程间（线程间）同步用的，一个进程（线程）完成了某一个动作就通过信号量告诉别的进程（线程），别的进程（线程）再进行某些动作。有二值和多值信号量之分。<br> 互斥锁：是线程间互斥用的，一个线程占用了某一个共享资源，那么别的线程就无法访问，直到这个线程离开，其他的线程才开始可以使用这个共享资源。可以把互斥锁看成二值信号量。</p><p>上锁时：<br> 信号量: 只要信号量的value大于0，其他线程就可以sem_wait成功，成功后信号量的value减一。若value值不大于0，则sem_wait阻塞，直到sem_post释放后value值加一。<br> 互斥锁: 只要被锁住，其他任何线程都不可以访问被保护的资源。如果没有锁，获得资源成功，否则进行阻塞等待资源可用。<br> 使用场所：         信号量主要适用于进程间通信，当然，也可用于线程间通信。而互斥锁只能用于线程间通信。</p><p>参考:</p><p><a href="https://zhuanlan.zhihu.com/p/88241719">Linux中的各种锁及其基本原理</a></p><p><a href="https://www.jianshu.com/p/5725db8f07dc">深入理解各种锁</a></p><h2 id="软链接和硬链接区别"><a href="#软链接和硬链接区别" class="headerlink" title="软链接和硬链接区别"></a>软链接和硬链接区别</h2><p>到这里我们其实可以总结一下了：</p><ul><li>硬链接： 与普通文件没什么不同，<code>inode</code> 都指向同一个文件在硬盘中的区块</li><li>软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。</li></ul><p><a href="https://www.jianshu.com/p/dde6a01c4094">参考</a></p><h2 id="静态变量初始化"><a href="#静态变量初始化" class="headerlink" title="静态变量初始化"></a>静态变量初始化</h2><p>静态变量的内存分配和初始化</p><p>对于C语言的全局和静态变量，不管是否被初始化，其内存空间都是全局的；如果初始化，那么初始化发生在任何代码执行之前，属于编译期初始化。由于内置变量无须资源释放操作，仅需要回收内存空间，因此程序结束后全局内存空间被一起回收，不存在变量依赖问题，没有任何代码会再被执行！</p><p>C++引入了对象，这给全局变量的管理带领新的麻烦。C++的对象必须有构造函数生成，并最终执行析构操作。由于构造和析构并非分配内存那么简单，可以说相当复杂，因此何时执行全局或静态对象（C++）的构造和析构呢？这需要执行相关代码，无法在编译期完成，因此C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造，并通过atexit()来管理对象的生命期，在程序结束之后（如调用exit，main），按FILO顺序调用相应的析构操作！</p><p>总结：</p><blockquote><p>全局变量、文件域的静态变量和类的静态成员变量在main执行之前的静态初始化过程中分配内存并初始化；局部静态变量（一般为函数内的静态变量）在第一次使用时分配内存并初始化。这里的变量包含内置数据类型和自定义类型的对象。</p></blockquote><p>静态变量初始化的线程安全性说明</p><blockquote><p>非局部静态变量一般在main执行之前的静态初始化过程中分配内存并初始化，可以认为是线程安全的；</p><p>局部静态变量在编译时，编译器的实现一般是在初始化语句之前设置一个局部静态变量的标识来判断是否已经初始化，运行的时候每次进行判断，如果需要初始化则执行初始化操作，否则不执行。这个过程本身不是线程安全的。</p></blockquote><p>参考:<a href="https://blog.csdn.net/u011723812/article/details/78151533">静态变量初始化的时机</a></p><h2 id="用户态和内核态的区别"><a href="#用户态和内核态的区别" class="headerlink" title="用户态和内核态的区别"></a><a href="https://www.cnblogs.com/gizing/p/10925286.html">用户态和内核态的区别</a></h2><p>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。</p><h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><blockquote><p><strong>个人理解：</strong>事件驱动(even-driven)，字面理解即：由事件去触发某个或者一系列动作。</p><p><strong>百度百科：</strong> 从事件角度说，事件驱动程序的基本结构是由一个事件收集器、一个事件发送器和一个事件处理器组成。 事件收集器专门负责收集所有事件，包括来自用户的（如鼠标、键盘事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。 事件发送器负责将收集器收集到的事件分发到目标对象中。 事件处理器做具体的事件响应工作。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">举个栗子：起床闹钟响了驱动我们该起床了，上课铃声响了驱动我们进教室上课、放学铃声响了驱动我们上课结束了可以爱干嘛干嘛去了。<br></code></pre></td></tr></table></figure><p>或许这个栗子符合你，但是对我来说根本不可能🙈，闹钟响了压根不会起床、不起床听不到上课铃、不去上课也听不到下课铃，GG</p><p>转入正题，事件驱动的应用无处不在比如：spring、netty、zookeeper、mq，而且事件【event】和监听器【listener】都是成对存在的，单个存在是没有意义的，下面手动实现一个事件驱动模型。</p><p>那么事件驱动模型的组成是怎样的呢？</p><h2 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h2><p>先去百度了一张模型图，当当当当~</p><p><img src="1649c0eb09b11679" alt="img"></p><p>说实话，图不是自己画的就是不满意，但是 <code>MAC</code> 上画图工具都找不到好用的，就懒得画了，把<strong>事件收集器</strong>  ==&gt; **事件中心 **，事件和监听器的关系可以是<code>1:1、1:N、N:M</code>，取决于自己的需求。</p><p>说下流程：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 系统启动，监听器把自己注册到事件中心，与某种事件进行绑定<br><span class="hljs-bullet">2.</span> 事件发送器发送事件到事件中心，事件中心去查找与处理该事件的监听器<br>复制代码<br></code></pre></td></tr></table></figure><p>过程非常简单，为什么要用事件驱动呢？刚好百度百科有个栗子，看完相信优秀的你就明白了：</p><blockquote><p>通常，我们写服务器处理模型的程序时，有以下几种模型：</p><p>（1）每收到一个请求，创建一个新的进程，来处理该请求；</p><p>（2）每收到一个请求，创建一个新的线程，来处理该请求；</p><p>（3）每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求</p><p>上面的几种方式，各有千秋，</p><p>第（1）种方法，由于创建新的进程的开销比较大，所以，会导致服务器性能比较差,但实现比较简单。</p><p>第（2）种方式，由于要涉及到线程的同步，有可能会面临死锁等问题。</p><p>第（3）种方式，在写应用程序代码时，逻辑比前面两种都复杂。</p><p>综合考虑各方面因素，一般普遍认为第（3）种方式是大多数网络服务器采用的方式</p></blockquote><p><em>实际上，事件驱动模型的核心就是</em>  <strong>线程池</strong> ！！！ 来实现异步非阻塞。</p><p>转自：<a href="https://juejin.cn/post/6844903638377168909">传送门</a></p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>多路复用包括：</p><ul><li>select：线性扫描所有监听的文件描述符，不管他们是不是活跃的。有最大数量限制（32位系统1024，64位系统2048）</li><li>poll：同select，不过数据结构不同，需要分配一个pollfd结构数组，维护在内核中。它没有大小限制，不过需要很多复制操作</li><li>epoll：用于代替poll和select，没有大小限制。使用一个文件描述符管理多个文件描述符，使用红黑树存储。同时用事件驱动代替了轮询。epoll_ctl中注册的文件描述符在事件触发的时候会通过回调机制激活该文件描述符。epoll_wait便会收到通知。最后，epoll还采用了mmap虚拟内存映射技术减少用户态和内核态数据传输的开销</li></ul><h2 id="五种IO模型介绍和对比"><a href="#五种IO模型介绍和对比" class="headerlink" title="五种IO模型介绍和对比"></a>五种IO模型介绍和对比</h2><p>blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪。<br>先回答最简单的这个：blocking与non-blocking。前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还在准备数据的情况下会立刻返回。<br>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的：<br>* A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;<br>* An asynchronous I/O operation does not cause the requesting process to be blocked;<br>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个系统调用。<strong>non-blocking IO在执行recvfrom这个系统调用的时候，如果kernel的数据没有准备好，这时候不会block进程。但是当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内进程是被block的。</strong>而asynchronous IO则不一样，当进程发起IO操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p><p><strong>阻塞IO，非阻塞IO，IO复用，信号驱动IO，异步IO</strong>。前四种都属于同步IO。阻塞IO不必说了。非阻塞IO ，IO请求时加上O_NONBLOCK一类的标志位，立刻返回，IO没有就绪会返回错误，需要请求进程主动轮询不断发IO请求直到返回正确。IO复用同非阻塞IO本质一样，不过利用了新的select系统调用，由内核来负责本来是请求进程该做的轮询操作。看似比非阻塞IO还多了一个系统调用开销，不过因为可以支持多路IO，才算提高了效率。信号驱动IO，调用sigaltion系统调用，当内核中IO数据就绪时以SIGIO信号通知请求进程，请求进程再把数据从内核读入到用户空间，这一步是阻塞的。<br>异步IO，如定义所说，不会因为IO操作阻塞，IO操作全部完成才通知请求进程。<br>各个IO Model的比较如图所示：</p><p><img src="v2-3d67840eb606c5a2bd8490276634936e_1440w.jpg" alt="img"></p><p>经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p><p><a href="https://juejin.cn/post/6844903728718462990#heading-8">参考</a>:很详细</p><p><a href="https://zhuanlan.zhihu.com/p/54580385">参考</a>:更详细</p><h2 id="请问怎么实现线程池"><a href="#请问怎么实现线程池" class="headerlink" title="请问怎么实现线程池"></a>请问怎么实现线程池</h2><p>1.设置一个生产者消费者队列，作为临界资源<br>2.初始化n个线程，并让其运行起来，加锁去队列取任务运行<br>3.当任务队列为空的时候，所有线程阻塞<br>4.当生产者队列来了一个任务后，先对队列加锁，把任务挂在到队列上，然后使用条件变量去通知阻塞中的一个线程</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2021/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么TCP是三次握手而不是两次或者四次"><a href="#为什么TCP是三次握手而不是两次或者四次" class="headerlink" title="为什么TCP是三次握手而不是两次或者四次"></a>为什么TCP是三次握手而不是两次或者四次</h2><h3 id="一、资源浪费观点"><a href="#一、资源浪费观点" class="headerlink" title="一、资源浪费观点"></a>一、资源浪费观点</h3><p>如果只有两次握手，当客户端的SYN请求连接在网络管道中阻塞，客户端没有接收到ACK报文，就会重新发送SYN，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的ACK确认信号，所以每收到一个SYN就只能主动建立一个连接，这会造成什么情况呢？如果客户端的SYN阻塞了，重复发送多次SYN报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。<br>即两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求SYN报文，而造成重复分配资源。</p><h3 id="二、可靠性论断"><a href="#二、可靠性论断" class="headerlink" title="二、可靠性论断"></a>二、可靠性论断</h3><p>另外一种是 如果想确定双通道通畅，必须使用三个包的发送接收，也就是三次握手：“这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足”在不可靠信道上可靠地传输信息”这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了.”<br>三次是保证双方互相明确对方能收能发的最低值。理论上讲不论握手多少次都不能确认一条信道是“可靠”的，但通过3次握手可以至少确认它是“可用”的，再往上加握手次数不过是提高“它是可用的”这个结论的可信程度。另外Tcp的可靠传输更多的是靠重传机制来保证的</p><h3 id="三、初始序列号"><a href="#三、初始序列号" class="headerlink" title="三、初始序列号"></a>三、初始序列号</h3><p>三次握手的本质是为了同步双方的初始序列号：<br>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。TCP建立连接的握手，实质上就是建立一个双向的可靠通信连接，一边一个来回，每一边都自带超时重传来确保可靠性(而不是靠握手的次数)。TCP的3次握手是优化的结果，其实它应该是4次握手，由于是从零开始的建立连接，因此将SYN的ACK以及被动打开的SYN合并成了一个SYN-ACK。<br>握手的作用，旨在确定两个双向的初始序列号，TCP用序列号来编址传输的字节，由于是两个方向的连接，所以需要两个序列号，握手过程不传输任何字节，仅仅确定初始序列号。</p><h3 id="为什么TCP4次挥手时等待为2MSL？"><a href="#为什么TCP4次挥手时等待为2MSL？" class="headerlink" title="为什么TCP4次挥手时等待为2MSL？"></a>为什么TCP4次挥手时等待为2MSL？</h3><p>主动断开的一侧为A，被动断开的一侧为B。</p><ul><li><p>第一个消息：A发FIN</p></li><li><p>第二个消息：B回复ACK</p></li><li><p>第三个消息：B发出FIN</p></li></ul><p>此时此刻：B单方面认为自己与A达成了共识，即双方都同意关闭连接。</p><p>此时，B能释放这个TCP连接占用的内存资源吗？<strong>不能，B一定要确保A收到自己的ACK、FIN。</strong></p><p>所以B需要静静地等待A的第四个消息的到来：</p><p><strong>第四个消息：A发出ACK，用于确认收到B的FIN</strong></p><p>当B接收到此消息，即认为双方达成了同步：双方都知道连接可以释放了，此时B可以安全地释放此TCP连接所占用的内存资源、端口号。</p><p>所以<strong>被动关闭的B无需任何wait time，直接释放资源。</strong></p><p>但，A并不知道B是否接到自己的ACK，A是这么想的：</p><p>1）如果B没有收到自己的ACK，会超时重传FiN</p><p>那么A再次接到重传的FIN，会再次发送ACK</p><p>2）如果B收到自己的ACK，也不会再发任何消息，包括ACK</p><p>无论是1还是2，A都需要等待，要取这两种情况等待时间的最大值，<strong>以应对最坏的情况发生</strong>，这个最坏情况是：</p><p>去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。</p><p>这恰恰就是<strong>2MSL( Maximum Segment Life)。</strong></p><p>等待2MSL时间，A就可以放心地释放TCP占用的资源、端口号，<strong>此时可以使用该端口号连接任何服务器。</strong></p><p><strong>为何一定要等2MSL？</strong><br><strong>如果不等，释放的端口可能会重连刚断开的服务器端口，这样依然存活在网络里的老的TCP报文可能与新TCP连接报文冲突，造成数据冲突，为避免此种情况，需要耐心等待网络老的TCP连接的活跃报文全部死翘翘，2MSL时间可以满足这个需求（尽管非常保守）！</strong></p><h2 id="C-S-和-B-S-模式的区别与联系"><a href="#C-S-和-B-S-模式的区别与联系" class="headerlink" title="C/S 和 B/S 模式的区别与联系"></a>C/S 和 B/S 模式的区别与联系</h2><h3 id="C-S与B-S的定义、"><a href="#C-S与B-S的定义、" class="headerlink" title="C/S与B/S的定义、"></a>C/S与B/S的定义、</h3><ul><li> C/S (<strong>Client/Server</strong>)结构，即大家熟知的客户机和服务器结构。它是软件系统体系结构，通过它可以充分利用两端硬件环境的优势，将任务合理分配到Client端和Server端来实现，降低了系统的通讯开销。</li><li> B/S（<strong>Browser/Server</strong>）结构即浏览器和服务器结构。它是随着Internet技术的兴起，对C/S结构的一种变化或者改进的结构。在这种结构下，用户工作界面是通过WWW浏览器来实现，极少部分事务逻辑在前端（Browser）实现，但是主要事务逻辑在服务器端（Server）实现，形成所谓三层3-tier结构。这样就大大简化了客户端电脑载荷，减轻了系统维护与升级的成本和工作量，降低了用户的总体成本（TCO）。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="C-S模式"><a href="#C-S模式" class="headerlink" title="C/S模式"></a>C/S模式</h4><p>1.C/S模式将应用与服务分离,系统具有稳定性和灵活性<br>2.C/S模式配备的是点对点的结构模式,适用于局域网,有可靠的安全性<br>3.由于客户端实现与服务器端的直接连接,没有中间环节,因此响应速度快<br>4.在C/S模式中,作为客户机的计算机都要安装客户机程序,一旦软件系统升级,每台客户机都要安装客户机程序,系统升级和维护较为复杂。</p><h4 id="B-S模式"><a href="#B-S模式" class="headerlink" title="B/S模式"></a>B/S模式</h4><p>1.系统开发、维护、升级方便<br>每当服务器应用程序升级时，只要在服务器上升级服务应用程序即可，用户计算机上的浏览器软件不需要修改，系统开发和升级维护方便<br>2.B/S模式具有很强的开放性<br>在B/S模式下，用户通过通用的浏览器进行访问，系统开放性好<br>3.B/S模式的结构易于扩展<br>由于Web的平台无关性，B/S模式的结构可以任意扩展，可以从包含一台服务器和几个用户的小型系统扩展成为拥有成千上万个用户的大型系统<br>4.用户使用方便<br>B/S模式的应用软件都是基于Web浏览器的，而Web浏览器的界面是类似的。对于无用户交换功能的页面。用户接触的界面都是一致的，用户使用方便。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>必须强调：C/S和B/S并没有本质的区别：B/S是基于特定通信协议(HTTP)的C/S架构，也就是说B/S包含在C/S中，是<strong>特殊的C/S架构</strong>。</p><p>之所以在C/S架构上提出B/S架构，是为了满足瘦客户端、一体化客户端的需要，最终目的节约客户端更新、维护等的成本，及广域资源的共享。</p><ol><li>B/S属于C/S，浏览器只是特殊的客户端；</li><li>C/S可以使用任何通信协议，而B/S这个特殊的C/S架构规定必须实现HTTP协议；</li><li>浏览器是一个通用客户端，本质上开发浏览器，还是实现一个C/S系统。</li></ol><p>​    C/S和B/S是当今世界开发模式技术架构的两大主流技术。C/S是美国 Borland公司最早研发，B/S是美国微软公司研发。目前，这两项技术以被世界各国所掌握，这两种技术都有自己一定的市场份额和客户群。</p><p>​    我们不能简单的说是C/S还是B/S好，B／S结构的主要特点是分布性强、维护方便、开发简单且共享性强、总体拥有成本低。但数据安全性问题、对服务器要求过高、数据传输速度慢、软件的个性化特点明显降低，这些缺点是有目共睹的，难以实现传统模式下的特殊功能要求。例如通过浏览器进行大量的数据输入或进行报表的应答、专用性打印输出都比较困难和不便。此外，实现复杂的应用构造有较大的困难。虽然可以用ActiveX、Java等技术开发较为复杂的应用，但是相对于发展已非常成熟C／S的一系列应用工具来说，这些技术的开发复杂，并没有完全成熟的技术工具供使用。只能说两种开发模式各有优缺点和使用的范围：B/S适用于用户群庞大，或客户需求经长发生变化的情况。C/S功能强大，可以减轻服务器端压力，如果用户的需求特别复杂，用C/S。</p><p>​     但是随着Windows将浏览器技术植入操作系统内部，B/S结构已越来越受到欢迎，客户机越来越”瘦”而服务器越来越”胖”是将来软件的主流发展方向。</p><h2 id="KeepAlive详解"><a href="#KeepAlive详解" class="headerlink" title="KeepAlive详解"></a>KeepAlive详解</h2><h3 id="为什么要有KeepAlive？"><a href="#为什么要有KeepAlive？" class="headerlink" title="为什么要有KeepAlive？"></a><strong>为什么要有KeepAlive？</strong></h3><p>链接建立之后，如果应用程序或者上层协议一直不发送数据，或者隔很长时间才发送一次数据，当链接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，链接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。</p><p>TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文给对方，如果对方回应了这个报文，说明对方还在线，链接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持链接。</p><h3 id="如何开启KeepAlive"><a href="#如何开启KeepAlive" class="headerlink" title="如何开启KeepAlive?"></a><strong>如何开启KeepAlive?</strong></h3><p>KeepAlive并不是默认开启的，在Linux系统上没有一个全局的选项去开启TCP的KeepAlive。需要开启KeepAlive的应用必须在TCP的socket中单独开启。Linux Kernel有三个选项影响到KeepAlive的行为：</p><p>1.net.ipv4.tcpkeepaliveintvl = 75<br>2.net.ipv4.tcpkeepaliveprobes = 9<br>3.net.ipv4.tcpkeepalivetime = 7200</p><p>tcpkeepalivetime的单位是秒，表示TCP链接在多少秒之后没有数据报文传输启动探测报文; tcpkeepaliveintvl单位是也秒,表示前一个探测报文和后一个探测报文之间的时间间隔，tcpkeepaliveprobes表示探测的次数。</p><p>TCP socket也有三个选项和内核对应，通过setsockopt系统调用针对单独的socket进行设置：<br>TCPKEEPCNT: 覆盖 tcpkeepaliveprobes<br>TCPKEEPIDLE: 覆盖 tcpkeepalivetime<br>TCPKEEPINTVL: 覆盖 tcpkeepalive_intvl</p><p>举个例子，以我的系统默认设置为例，kernel默认设置的tcpkeepalivetime是7200s, 如果我在应用程序中针对socket开启了KeepAlive,然后设置的TCP_KEEPIDLE为60，那么TCP协议栈在发现TCP链接空闲了60s没有数据传输的时候就会发送第一个探测报文。</p><h3 id="TCP-KeepAlive和HTTP的Keep-Alive是一样的吗？"><a href="#TCP-KeepAlive和HTTP的Keep-Alive是一样的吗？" class="headerlink" title="TCP KeepAlive和HTTP的Keep-Alive是一样的吗？"></a><strong>TCP KeepAlive和HTTP的Keep-Alive是一样的吗？</strong></h3><p>估计很多人乍看下这个问题才发现其实经常说的KeepAlive不是这么回事，实际上在没有特指是TCP还是HTTP层的KeepAlive，不能混为一谈。TCP的KeepAlive和HTTP的Keep-Alive是完全不同的概念。</p><p>一个完整的HTTP事务，有链接的建立，请求的发送，响应接收，断开链接这四个过程,早期通过HTTP协议传输的数据以文本为主，一个请求可能就把所有要返回的数据取到，但是，现在要展现一张完整的页面需要很多个请求才能完成，如图片,JS,CSS等，如果每一个HTTP请求都需要新建并断开一个TCP，这个开销是完全没有必要的。</p><p>开启HTTP Keep-Alive之后，能复用已有的TCP链接，当前一个请求已经响应完毕，服务器端没有立即关闭TCP链接，而是等待一段时间接收浏览器端可能发送过来的第二个请求，通常浏览器在第一个请求返回之后会立即发送第二个请求，如果某一时刻只能有一个链接，同一个TCP链接处理的请求越多，开启KeepAlive能节省的TCP建立和关闭的消耗就越多。</p><p>当然通常会启用多个链接去从服务器器上请求资源，但是开启了Keep-Alive之后，仍然能加快资源的加载速度。HTTP/1.1之后默认开启Keep-Alive, 在HTTP的头域中增加Connection选项。当设置为Connection:keep-alive表示开启，设置为Connection:close表示关闭。实际上HTTP的KeepAlive写法是Keep-Alive，跟TCP的KeepAlive写法上也有不同。所以TCP KeepAlive和HTTP的Keep-Alive不是同一回事情。</p><p><strong>一个完整的HTTP事务，有链接的建立，请求的发送，响应接收，断开链接这四个过程,早期通过HTTP协议传输的数据以文本为主，一个请求可能就把所有要返回的数据取到，但是，现在要展现一张完整的页面需要很多个请求才能完成，如图片,JS,CSS等，如果每一个HTTP请求都需要新建并断开一个TCP，这个开销是完全没有必要的。</strong></p><p>开启HTTP Keep-Alive之后，能复用已有的TCP链接，当前一个请求已经响应完毕，服务器端没有立即关闭TCP链接，而是等待一段时间接收浏览器端可能发送过来的第二个请求，通常浏览器在第一个请求返回之后会立即发送第二个请求，如果某一时刻只能有一个链接，同一个TCP链接处理的请求越多，开启KeepAlive能节省的TCP建立和关闭的消耗就越多。</p><p>当然通常会启用多个链接去从服务器器上请求资源，但是开启了Keep-Alive之后，仍然能加快资源的加载速度。HTTP/1.1之后默认开启Keep-Alive, 在HTTP的头域中增加Connection选项。当设置为Connection:keep-alive表示开启，设置为Connection:close表示关闭。实际上HTTP的KeepAlive写法是Keep-Alive，跟TCP的KeepAlive写法上也有不同。所以TCP KeepAlive和HTTP的Keep-Alive不是同一回事情。</p><h2 id="HTTP是无连接的吗"><a href="#HTTP是无连接的吗" class="headerlink" title="HTTP是无连接的吗"></a>HTTP是无连接的吗</h2><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p><p>从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接3</p><p>那么HTTP到底是不是无连接的呢？</p><h3 id="优质回答："><a href="#优质回答：" class="headerlink" title="优质回答："></a>优质回答：</h3><p>是无连接的，虽然目前的- -些新技术如你说的keep-Alive使用了长连接优化效率，但这些都是属于HTTP请求之外的，也就是说，在每个独立的HTTP请求中，你是无法知道当前的HTTP是否处于长连接的状态(即使这个请求可能标记为Keep-Alive) ,你始终都要认为HTTP请求在结束后连接就会关闭。这是HTTP的特性，至于下层实现是否在结束请求后关闭连接，都不会改变这个特性，长连接可以理解为下层实现对上层透明。</p><h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h2><p>1、概括</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</p><p>2、区别：</p><p>​    1、概括</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</p><p>2、区别：</p><ol><li>get参数通过url传递，post放在request body中。</li><li>get请求在url中传递的参数是有长度限制的，而post没有。</li><li>get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。</li><li>get请求只能进行url编码，而post支持多种编码方式。</li><li>get请求会浏览器主动cache，而post支持多种编码方式。</li><li>get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。</li><li>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</li><li>GET产生一个TCP数据包；POST产生两个TCP数据包。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl <span class="hljs-string">&quot;http://lipadress/url&quot;</span> -X POST -d <span class="hljs-string">&#x27;username=xts&amp;password=123456&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="Socket-套接字"><a href="#Socket-套接字" class="headerlink" title="Socket(套接字)"></a>Socket(套接字)</h2><h3 id="Socket概念理解"><a href="#Socket概念理解" class="headerlink" title="Socket概念理解"></a>Socket概念理解</h3><p>Socket是一种进程通信机制，凭借这种机制，客户/服务器系统的开发工作既可以在本地单机上进行，也可以跨网络进行。</p><p>网络通信归根结底是不同主机上的应用程序进程之间的交互，我们可以通过应用层协议HTTP，解决如何包装数据，但有时我们也想直接使用传输层协议，而Socket就相当于是传输层的编程接口。应用通过传输层进行数据通信时，TCP和UDP会遇到同时为多个应用程序进程提供并发服务的问题。为了区别不同的应用程序进程和连接，计算机操作系统就可以为应用程序与TCP/IP协议交互提供套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p><p>Socket并不是一种协议，可以将Socket理解为方便直接使用更底层协议（传输层TCP或UDP）而存在的一个抽象层。Socket跟TCP/IP协议没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议，Socket只是使得用TCP/IP协议栈更方便而已。所以Socket是对TCP/IP协议的封装，它是一组接口。这组接口当然可以由不同的语言去实现。它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。用套接字中的相关函数来完成通信过程。</p><p>Socket是面向客户/服务器模型而设计的，针对客户和服务器程序提供不同的Socket系统调用。通过Socket建立通信连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。Socket原意是 “插座”，两个Socket端点的连接，就像连接一个插座获取服务一样。套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p><p><img src="669609-b8a1134b6fe3d028.png" alt="img"></p><p>在一台计算机本机上可以通过PID唯一标识一个进程，而区分不同应用程序进程间的网络通信和连接,主要有3个参数：通信的目的IP地址、使用的传输层协议(TCP或UDP)和使用的端口号。通过将这3个参数结合起来，与一个Socket绑定，应用层就可以和传输层通过套接字接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p><p>Socket通过这些信息成为网络通信中的一个端点，是连接应用程序和网络驱动程序的桥梁，Socket在应用程序中创建，通过绑定与网络驱动建立关系。此后，应用程序送给Socket的数据，由Socket交给网络驱动程序向网络上发送出去。计算机从网络上收到与该Socket绑定IP地址和端口号相关的数据后，由网络驱动程序交给Socket，应用程序便可从该Socket中提取接收到的数据，网络应用程序就是这样通过Socket进行数据的发送与接收的。</p><h2 id="Chrome-为什么多进程而不是多线程？"><a href="#Chrome-为什么多进程而不是多线程？" class="headerlink" title="Chrome 为什么多进程而不是多线程？"></a>Chrome 为什么多进程而不是多线程？</h2><p><a href="https://blog.chromium.org/2008/09/multi-process-architecture.html">传送门</a></p><p>多进程最大的优势就是安全性，这也是 Chromium 要搞多进程的最主要原因。例如标签页和插件处于不同的进程，相当于运行在不同的沙盒环境中。整个 Chromium 包含各种“引擎”，未知的 BUG 几乎是无法避免的，单进程架构会导致整个浏览器崩溃或卡死（如果你是悠久的火狐用户，这种情况应该不少见）。</p><p>Chrome 把自己抽象为一个操作系统，网页或扩展相当于一个个程序，你甚至可以注意到 Chrome 确实自带一个任务管理器。对于操作系统而言，程序进程互相独立，这没什么好奇怪的。</p><p>你说多线程性能更高，这是不论场景的很狭隘的对比的方式。多进程因为内存不共享导致产生多余的通信开销，理论上性能会降低，但这只能表示单个网页的渲染速度。</p><p>当一个浏览器存在更多的渲染任务的时候，多进程的并行化程度往往更高。因为互不相关的网页渲染过程彼此独立，减少了不必要的 CPU 争用，整体性能可能反而会更高。</p><hr><p>Chrome的多进程设计还具有其他与性能相关的优势：</p><ul><li><p>一个选项卡的执行不能阻止其他选项卡的执行。操作系统确保进程公平地共享对CPU和内存的访问。</p></li><li><p>简单粗暴解决了内存泄漏。当不再需要某个进程时（比如关闭选项卡时），其所有内存将全部交给操作系统。而在更单一的浏览器设计中，这一步则难以做到。因此，随着时间的流逝，在大型单进程应用程序中，基线内存使用量将趋于上升。这种情况也发生在Chrome中（由于其单一的主进程），但是多进程设计至少可以确保始终完全释放用于渲染网页的内存。</p></li></ul><hr><ul><li>不稳定</li></ul><p>早期浏览器需要借助于插件来实现诸如 Web 视频、Web 游戏等各种强大的功能，但是插 件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起 整个浏览器的崩溃。 除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的 JavaScript 代码就有可能引 起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃。</p><ul><li>不流畅</li></ul><p>从上面的“单进程浏览器架构示意图”可以看出，所有页面的渲染模块、JavaScript 执行 环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。</p><p>如果不巧谁写了一段无限循环的JS代码，那么你想象下它会独占整个线程，这样导致其他运行在该 线程中的模块就没有机会被执行。因为浏览器中所有的页面都运行在该线程中，所以这些页 面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。</p><p>除了上述脚本或者插件会让单进程浏览器变卡顿外，页面的内存泄漏也是单进程变慢的一个 重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在 内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得 越慢。</p><ul><li>不安全</li></ul><p>插件和页面脚本是两大不安全因素之一。</p><p>多进程自然也有它的弊端，比如最明显的内存占用高。 因为每个进程都有自己的私有内存空间，因此它们通常包含公有基础功能（例如 V8 是 Chrome 的 JavaScript 引擎）。这意味着更多的内存使用，因为如果它们是同一进程内的线程，则无法以它们的方式共享。为了节省内存，Chrome 限制了它可以启动的进程数量。限制会根据设备的内存和 CPU 功率动态调整，但当 Chrome 达到限制时，它会在一个新的进程中打开这个站点。</p><h2 id="最大传输单元"><a href="#最大传输单元" class="headerlink" title="最大传输单元"></a>最大传输单元</h2><p>IP 协议是用于传输数据包的协议，作为网络层协议，它能提供数据的路由和寻址功能，让数据通过网络到达目的地。不同设备之间传输数据前，需要先确定一个 IP 数据包的大小上限，即最大传输单元（Maximum transmission unit，即 MTU），MTU 是 IP 数据包能够传输的数据上限。</p><p>MTU 的值不是越大越好，更大的 MTU 意味着更低的额外开销，更小的 MTU 意味着更低的网络延迟。每一个物理设备都有自己的 MTU，两个主机之间的 MTU 依赖于底层的网络能力，它由整个链路上 MTU 最小的物理设备决定，如下图所示，网络路径的 MTU 由 MTU 最小的红色物理设备决定，即 1000：</p><p><img src="2020-02-12-15814868931881-path-mtu-discovery.png" alt="path-mtu-discovery"></p><p>以太网对数据帧的限制一般都是 1500 字节，在一般情况下，IP 主机的路径 MTU 都是 1500，去掉 IP 首部的 20 字节，如果待传输的数据大于 1480 节，那么该 IP 协议就会将数据包分片传输。</p><p>IP 协议数据分片对传输层协议是透明的，假设我们使用 UDP 协议传输 2000 字节的数据，加上 UDP 8 字节的协议头<a href="https://draveness.me/whys-the-design-tcp-segment-ip-packet/#fn:7">7</a>，IP 协议需要传输 2008 字节的数据。如下图所示，当 IP 协议发现待传输的数据大于 1480 字节，就会将数据分成下面的两个数据包：</p><p><img src="2020-02-12-15814868931890-udp-ip-packet.png" alt="udp-ip-packet"></p><pre><code>1. 20 字节 IP 协议头 + 8 字节 UDP 协议头 + 1472 字节数据；2. 20 字节 IP 协议头 + 528 字节数据；</code></pre><p>数据的接收方在收到数据包时会对分片的数据进行重组，不过因为第二个数据包中不包含 UDP 协议的相关信息，一旦发生丢包，整个 UDP 数据报就无法重新拼装。如果 UDP 数据报需要传输的数据过多，那么 IP 协议就会大量分片，增加了不稳定性。</p><p>如果 IP 协议没有数据包大小的限制，那么上层可以以消息为单位传输数据，自然就不存在分片和组装的需求，不过因为物理设备的 MTU 限制，想要保证数据传输的可靠性和稳定性还需要传输层的配合。</p><h3 id="最大分段大小"><a href="#最大分段大小" class="headerlink" title="最大分段大小"></a>最大分段大小</h3><p>TCP 协议是面向字节流的协议，应用层交给 TCP 协议的数据并不会以消息为单位向目的主机发送，应用层交给 TCP 协议发送的数据可能会被拆分到多个数据段中。</p><p>TCP 协议引入了最大分段大小（Maximum segment size，MSS）这一概念，它是 TCP 数据段能够携带的数据上限。在正常情况下，TCP 连接的 MSS 是 MTU - 40 字节，即 1460 字节；不过如果通信双方没有指定 MSS 的话，在默认情况下 MSS 的大小是 536 字节。</p><p><strong>IP 协议的 MTU 是物理设备上的限制，它限制了路径能够发送数据包的上限，而 TCP 协议的 MSS 是操作系统内核层面的限制，通信双方会在三次握手时确定这次连接的 MSS。一旦确定了 MSS，TCP 协议就会对应用层交给 TCP 协议发送的数据进行拆分，构成多个数据段。</strong></p><p>需要注意的是，IP 协议和 TCP 协议虽然都会对数据进行拆分，但是 IP 协议以数据包（Package）为单位组织数据，而 TCP 协议以数据段（Segment）为单位组织数据。</p><p>如下图所示，如果 TCP 连接的 MSS 是 1460 字节，应用层想要通过 TCP 协议传输 2000 字节的数据，那么 TCP 协议会根据 MSS 将 2000 字节的数据拆分到两个数据段中：<img src="2020-02-12-15814868931896-tcp-ip-packet.png" alt="tcp-ip-packet"></p><ul><li>20 字节 IP 头 + 20 字节 TCP 头 + 1460 字节数据；</li><li>20 字节 IP 头 + 20 字节 TCP 头 + 540 字节数据；</li></ul><p>从应用层的角度来看，两个数据段中 2000 字节的数据构成了发送方想要发送的消息，但是 TCP 协议是面向字节流的，向协议写入的数据会以流的形式传递到对端。</p><p>TCP 协议为了保证可靠性，会通过 IP 协议的 MTU 计算出 MSS 并根据 MSS 分段避免 IP 协议对数据包进行分片。因为 IP 协议对数据包的分片对上层是透明的，如果协议不根据 MTU 做一些限制，那么 IP 协议的分片会导致部分数据包失去传输层协议头，一旦数据包发生丢失就只能丢弃全部数据。</p><p>我们可以通过一个例子分析 MSS 存在的必要性。如下图所示，假设 TCP 协议中不存在 MSS 的概念，因为每个数据段的大小没有上限，当 TCP 协议交给 IP 层发送两个 1600 字节（包括 IP 和 TCP 协议头）的数据包时，由于物理设备的限制，IP 协议的路径 MTU 为 1500 字节，所以 IP 协议会对数据包分片：</p><p><img src="2020-02-12-15814868931902-tcp-ip-packet-with-ip-fragmentation.png" alt="tcp-ip-packet-with-ip-fragmentation"></p><p>四个数据包中只有两个会包含 TCP 协议头，即控制位、序列号等信息，剩下的两个数据包中不包含任何信息。当 IP 协议传输数据丢包时，TCP 协议的接收方没有办法对数据包进行重组，所以整个 TCP 数据段都需要重传，带来了更多额外的重传和重组开销。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>数据拆分的根本原因说到底还是物理设备的限制，不过每一层协议都受限于下一层协议做出的决定，并依赖下层协议重新决定设计和实现的方法。虽然 TCP/IP 协议在传输数据时都需要对数据进行拆分，但是它们做出拆分数据的设计基于不同的上下文，也有着不同的目的，我们在这里总结一下两个网络协议做出类似决定的原因：</p><ul><li>IP 协议拆分数据是因为物理设备的限制，一次能够传输的数据由路径上 MTU 最小的设备决定，一旦 IP 协议传输的数据包超过 MTU 的限制就会发生丢包，所以我们需要通过路径 MTU 发现获取传输路径上的 MTU 限制；</li><li>TCP 协议拆分数据是为了保证传输的可靠性和顺序，作为可靠的传输协议，为了保证数据的传输顺序，它需要为每一个数据段增加包含序列号的 TCP 协议头，如果数据段大小超过了 IP 协议的 MTU 限制， 就会带来更多额外的重传和重组开销，影响性能。</li></ul><h2 id="localhost与127-0-0-1的区别"><a href="#localhost与127-0-0-1的区别" class="headerlink" title="localhost与127.0.0.1的区别"></a>localhost与127.0.0.1的区别</h2><p>localhost也叫local ，正确的解释是：本地服务器</p><p>127.0.0.1在windows等系统的正确解释是：本机地址（本机服务器）</p><p>localhot（local）是不经网卡传输！这点很重要，它不受网络防火墙和网卡相关的的限制。</p><p>127.0.0.1是通过网卡传输，依赖网卡，并受到网络防火墙和网卡相关的限制。</p><p>一般设置程序时本地服务用localhost是最好的，localhost不会解析成ip，也不会占用网卡、网络资源。</p><p>有时候用localhost可以，但用127.0.0.1就不可以的情况就是在于此。</p><p><img src="/img/localhost%E4%B8%8E127%E5%8C%BA%E5%88%AB.jpg"></p><h2 id="post与body"><a href="#post与body" class="headerlink" title="post与body"></a>post与body</h2><p>根据Http的请求方法对应的数据传输能力把Http请求分为Url类请求和Body类请求，Url类请求包括但不限于GET、HEAD、 OPTIONS、TRACE等请求方法。Body类请求包括但不限于POST、PUSH、 PATCH、 DELETE 等请求方法。</p><p>在语义上来说，例如GET请求是查询或者获取服务端的资源的, POST请求是向服务器push数据或者创建资源的。其它同类请求方法多少都有点相同的含义，不过它们谁有谁该做的事，例如支持缓存,探测响应头和断点续传等。</p><h3 id="Url类请求释义"><a href="#Url类请求释义" class="headerlink" title="Url类请求释义"></a>Url类请求释义</h3><p>对于Url类请求,客户端是不能通过body写出数据的，服务端拿到的body是空的。因此-般情况下,我们提供的HttpClient被Url类的请求getOutputStream(的时候会抛一个异常，而HttpServer接受到Url类的请求后getInputStream()的时候也会抛一个异常, 这都是为了告诉调用者这是不合理的。</p><p>这里的HttpClient和HttpServer不是特指某框架或者浏览器， 而是个笼统的称呼。</p><p>因此Url类的请求想要提交参数，就把参数跟在ur后边了，但是url-般是指向资源的，因此url后面跟的参数更多的是一种条件和要求(例如阿里云OSS处理图片时)。</p><p><img src="20131219133501281" alt="img"></p><h3 id="Body类请求释义"><a href="#Body类请求释义" class="headerlink" title="Body类请求释义"></a>Body类请求释义</h3><p>Body类请求在语义和能力上来说应该是兼容Ur|类请求的，但是根据Http协议它们谁有谁该做的事。例如RESTful风格就是根据Http协议来提出的。</p><p>对于Body类请求，客户端可以通过body写出数据，服务端可以通过body接受数据。因此Body类请求能上传到服务端的数据比Url类请求的大的多。</p><p>Body类请求除了可以把参数放到url中,也可以通过body发送数据。</p><p>例如当Content-Type是application/x-www-form-urlencoded时,客户端可以通过body发送键值对数据，例如key1=value1&amp;key2=value2。</p><p>例如当Content-Type是application/json时,客户端可以通过body发送json字符串;如果是<br>application/xm时可以发送xml字符串。</p><p>例如当Content Type是application/octet stream时，客户端可以通过body发送Binary数据,例如文件或者任何能转成流的数据。</p><p>例如当Content Type是multipart/form-data时,客户端可以通过body发送一个表单。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go并发编程</title>
    <link href="/2021/03/23/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/03/23/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>同一时间段内执行多个任务, 逻辑上具有处理多个同时性任务的能力。</p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>同一时刻执行多个任务,物理上同一时刻执行多个并发任务。</p><p>Go语言的并发通过<code>goroutine</code>实现。<code>goroutine</code>类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。</p><p>Go语言还提供channel在多个<code>goroutine</code>间进行通信。<code>goroutine</code>和channel是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。</p><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p><code>goroutine</code>的概念类似于线程，但 <code>goroutine</code>是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 <code>goroutine</code> 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p><h3 id="使用goroutine"><a href="#使用goroutine" class="headerlink" title="使用goroutine"></a>使用goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Hello %v\n&quot;</span>, i)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br><span class="hljs-keyword">go</span> hello(i)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;main done!&quot;</span>)<br>time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="goroutine什么时候结束？"><a href="#goroutine什么时候结束？" class="headerlink" title="goroutine什么时候结束？"></a>goroutine什么时候结束？</h3><p><code>goroutine</code>对应的函数结束了,<code>goroutine</code>结束了。<br><code>main</code>函数执行完了，由<code>main</code>函数创建的那些<code>goroutine</code>都结束了。</p><h3 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done() <span class="hljs-comment">// goroutine结束就登记-1</span><br>fmt.Println(<span class="hljs-string">&quot;Hello Goroutine!&quot;</span>, i)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 启动一个goroutine就登记+1</span><br><span class="hljs-keyword">go</span> hello(i)<br>&#125;<br>wg.Wait() <span class="hljs-comment">// 等待所有登记的goroutine都结束</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="goroutine与线程"><a href="#goroutine与线程" class="headerlink" title="goroutine与线程"></a>goroutine与线程</h2><h3 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a>可增长的栈</h3><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个<code>goroutine</code>的栈在其生命周期开始时只有很小的栈（典型情况下2KB），<code>goroutine</code>的栈不是固定的，他可以按需增大和缩小，<code>goroutine</code>的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go语言中一次创建十万左右的<code>goroutine</code>也是可以的。</p><h3 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h3><p><code>GPM</code>是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p><ul><li>G很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li><li>P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li><li>M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</li></ul><p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p><p>P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p><p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p><p><a href="https://www.cnblogs.com/sunsky303/p/9705727.html">深入Golang调度器之GMP模型</a></p><h3 id="runtime-GOMAXPROCS"><a href="#runtime-GOMAXPROCS" class="headerlink" title="runtime.GOMAXPROCS"></a>runtime.GOMAXPROCS</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;A:&quot;</span>, i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;B:&quot;</span>, i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//runtime.GOMAXPROCS(1)</span><br>runtime.GOMAXPROCS(<span class="hljs-number">2</span>) <span class="hljs-comment">//指定核心数</span><br>wg.Add(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">go</span> a()<br><span class="hljs-keyword">go</span> b()<br>fmt.Println(runtime.NumCPU())<br>wg.Wait()<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的<code>goroutine</code>中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>Go语言的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡通过通信共享内存而不是通过共享内存而实现通信。</p><p>如果说<code>goroutin</code>e是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个goroutine发送特定值到另一个<code>goroutine</code>的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode第224场周赛</title>
    <link href="/2021/03/22/LeetCode%E7%AC%AC224%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    <url>/2021/03/22/LeetCode%E7%AC%AC224%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode第224场周赛"><a href="#LeetCode第224场周赛" class="headerlink" title="LeetCode第224场周赛"></a>LeetCode第224场周赛</h1><h2 id="5653-可以形成最大正方形的矩形数目"><a href="#5653-可以形成最大正方形的矩形数目" class="headerlink" title="5653. 可以形成最大正方形的矩形数目"></a>5653. 可以形成最大正方形的矩形数目</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个数组 <code>rectangles</code> ，其中 <code>rectangles[i] = [li, wi]</code> 表示第 <code>i</code> 个矩形的长度为 <code>li</code> 、宽度为 <code>wi</code> 。</p><p>如果存在 <code>k</code> 同时满足 <code>k &lt;= li</code> 和 <code>k &lt;= wi</code> ，就可以将第 <code>i</code> 个矩形切成边长为 <code>k</code> 的正方形。例如，矩形 <code>[4,6]</code> 可以切成边长最大为 <code>4</code> 的正方形。</p><p>设 <code>maxLen</code> 为可以从矩形数组 <code>rectangles</code> 切分得到的 <strong>最大正方形</strong> 的边长。</p><p>返回可以切出边长为 <code>maxLen</code> 的正方形的矩形 <strong>数目</strong> 。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= rectangles.length &lt;= 1000</code></li><li><code>rectangles[i].length == 2</code></li><li><code>1 &lt;= li, wi &lt;= 109</code></li><li><code>li != wi</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>读题即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countGoodRectangles</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; a)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> maxlen=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;it:a)&#123;<br>            maxlen=max(maxlen,min(it[<span class="hljs-number">0</span>],it[<span class="hljs-number">1</span>]));<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;it:a)&#123;<br>            ans+=min(it[<span class="hljs-number">0</span>],it[<span class="hljs-number">1</span>])==maxlen;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5243-同积元组"><a href="#5243-同积元组" class="headerlink" title="5243. 同积元组"></a>5243. 同积元组</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个由 <strong>不同</strong> 正整数组成的数组 <code>nums</code> ，请你返回满足 <code>a * b = c * d</code> 的元组 <code>(a, b, c, d)</code> 的数量。其中 <code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> 都是 <code>nums</code> 中的元素，且 <code>a != b != c != d</code> 。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>设a&lt;b&lt;c&lt;d那么答案乘8即可，问题转换为求4元组满足 <code>a*d==c*d</code>，如果存在这样的四元组仅存在<code>a*b==c*d</code>的情况，化简得<code>a/c==d/b</code>那么我们枚举所有的<code>b和d</code>求在此之前出现过多少二元组相除的结果等于<code>d/b</code>即可，map存下即可</p><p>处理前需要先排序</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    pair&lt;int,int&gt; get(int x,int y)&#123;<br>        <span class="hljs-keyword">int</span> t=__gcd(x,y);<br>        <span class="hljs-keyword">return</span> &#123;y/t,x/t&#125;;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tupleSameProduct</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        sort(nums.begin(),nums.end());<br>        <span class="hljs-keyword">int</span> n=nums.size();<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">int</span>&gt;mp;<br>        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                ans+=mp[get(nums[i],nums[j])];<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                mp[get(nums[j],nums[i])]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans*<span class="hljs-number">8</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5655-重新排列后的最大子矩阵"><a href="#5655-重新排列后的最大子矩阵" class="headerlink" title="5655. 重新排列后的最大子矩阵"></a>5655. 重新排列后的最大子矩阵</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个二进制矩阵<code>matrix</code> ，它的大小为 <code>m x n</code> ，你可以将 matrix 中的 列 按任意顺序重新排列。</p><p>请你返回最优方案下将 matrix 重新排列后，全是 1 的子矩阵面积。</p><ul><li>m == matrix.length</li><li>n == matrix[i].length</li><li>1 &lt;= m * n &lt;= 100000</li><li>matrix[i][j] 要么是 0 ，要么是 1 。</li></ul><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>维护dp数组表示以a[i][j]为起点向上最多数字1的个数，之后枚举行，对每一行进行分析，发现就是一个简化边的最大直方图问题。</p><p>针对一行来说，dp[1],dp[2],dp[3],dp[4]将其降序排列后，那么dp[i]左侧都能覆盖到，即res=dp[i]*i，最后去max即可</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestSubmatrix</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; a)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n=a.size(),m=a[<span class="hljs-number">0</span>].size();<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;dp(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(m,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                <span class="hljs-keyword">if</span>(a[i][j]) dp[i][j]=i?dp[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;b;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            b=dp[i];<br>            sort(b.begin(),b.end(),greater&lt;<span class="hljs-keyword">int</span>&gt;());<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                res=max(res,b[j]*(j+<span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5529-猫和老鼠-II"><a href="#5529-猫和老鼠-II" class="headerlink" title="5529. 猫和老鼠 II"></a>5529. 猫和老鼠 II</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="点这里"><a href="#点这里" class="headerlink" title="点这里"></a><a href="https://leetcode-cn.com/problems/cat-and-mouse-ii/">点这里</a></h4><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>博弈</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> dp[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>][<span class="hljs-number">8</span>][<span class="hljs-number">8</span>][<span class="hljs-number">200</span>];<br><span class="hljs-keyword">int</span> fx[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> n,m,cj,mj;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;s;<br>    <span class="hljs-comment">//0猫赢 1鼠赢</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cx,<span class="hljs-keyword">int</span> cy,<span class="hljs-keyword">int</span> mx,<span class="hljs-keyword">int</span> my,<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(k&gt;=<span class="hljs-number">200</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>&amp; v=dp[cx][cy][mx][my][k];<br>        <span class="hljs-keyword">if</span>(v!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> v;<br><br>        <span class="hljs-keyword">if</span>(k&amp;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=cj;j++)&#123;<br>                    <span class="hljs-keyword">int</span> x=cx+fx[i][<span class="hljs-number">0</span>]*j,y=cy+fx[i][<span class="hljs-number">1</span>]*j;<br>                    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= n || y &lt; <span class="hljs-number">0</span> || y &gt;= m || s[x][y] == <span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">if</span>(x==mx&amp;&amp;y==my) <span class="hljs-keyword">return</span> v=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">if</span>(s[x][y]==<span class="hljs-string">&#x27;F&#x27;</span>) <span class="hljs-keyword">return</span> v=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">if</span>(!dfs(x,y,mx,my,k+<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> v=<span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> v=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=mj;j++)&#123;<br>                    <span class="hljs-keyword">int</span> x=mx+fx[i][<span class="hljs-number">0</span>]*j,y=my+fx[i][<span class="hljs-number">1</span>]*j;<br>                    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= n || y &lt; <span class="hljs-number">0</span> || y &gt;= m || s[x][y] == <span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">if</span> (x == cx &amp;&amp; y == cy) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-keyword">if</span>(s[x][y]==<span class="hljs-string">&#x27;F&#x27;</span>) <span class="hljs-keyword">return</span> v=<span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(dfs(cx,cy,x,y,k+<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> v=<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> v=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canMouseWin</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; grid, <span class="hljs-keyword">int</span> catJump, <span class="hljs-keyword">int</span> mouseJump)</span> </span>&#123;<br>        n=grid.size(),m=grid[<span class="hljs-number">0</span>].size(),cj=catJump,mj=mouseJump;<br>        s=grid;<br>        <span class="hljs-keyword">int</span> cx,cy,mx,my;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                <span class="hljs-keyword">if</span>(s[i][j]==<span class="hljs-string">&#x27;C&#x27;</span>) cx=i,cy=j;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i][j]==<span class="hljs-string">&#x27;M&#x27;</span>) mx=i,my=j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dp));<br>        <span class="hljs-keyword">return</span> dfs(cx,cy,mx,my,<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode第44场双周赛</title>
    <link href="/2021/03/22/leetcode%E7%AC%AC%2044%20%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    <url>/2021/03/22/leetcode%E7%AC%AC%2044%20%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="leetcode第-44-场双周赛"><a href="#leetcode第-44-场双周赛" class="headerlink" title="leetcode第 44 场双周赛"></a>leetcode第 44 场双周赛</h2><h3 id="找到最高海拔"><a href="#找到最高海拔" class="headerlink" title="找到最高海拔"></a>找到最高海拔</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>有一个自行车手打算进行一场公路骑行，这条路线总共由 n + 1 个不同海拔的点组成。自行车手从海拔为 0 的点 0 开始骑行。</p><p>给你一个长度为 n 的整数数组 gain ，其中 gain[i] 是点 i 和点 i + 1 的 净海拔高度差（0 &lt;= i &lt; n）。请你返回 最高点的海拔 。</p><p><strong>提示：</strong></p><ul><li><code>n == gain.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>-100 &lt;= gain[i] &lt;= 100</code></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>读题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestAltitude</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; gain)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>,now=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;v:gain)&#123;<br>            now+=v;<br>            ans=max(ans,now);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="需要教语言的最少人数"><a href="#需要教语言的最少人数" class="headerlink" title="需要教语言的最少人数"></a>需要教语言的最少人数</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个由 m 个用户组成的社交网络里，我们获取到一些用户之间的好友关系。两个用户之间可以相互沟通的条件是他们都掌握同一门语言。</p><p>给你一个整数 n ，数组 languages 和数组 friendships ，它们的含义如下：</p><ul><li><p>总共有 n 种语言，编号从 1 到 n 。</p></li><li><p>languages[i] 是第 i 位用户掌握的语言集合。</p></li><li><p>friendships[i] = [ui, vi] 表示 ui 和 vi 为好友关系。</p></li></ul><p>你可以选择 <strong>一门</strong> 语言并教会一些用户，使得所有好友之间都可以相互沟通。请返回你<strong>最少</strong>需要教会多少名用户。</p><p>请注意，好友关系没有传递性，也就是说如果 x 和 y 是好友，且 y 和 z 是好友， x 和 z 不一定是好友。</p><p><strong>提示：</strong></p><ul><li>2 &lt;= n &lt;= 500</li><li>languages.length == m</li><li>1 &lt;= m &lt;= 500</li><li>1 &lt;= languages[i].length &lt;= n</li><li>1 &lt;= languages[i][j] &lt;= n</li><li>1 &lt;= ui &lt; vi &lt;= languages.length</li><li>1 &lt;= friendships.length &lt;= 500</li><li>所有的好友关系 (ui, vi) 都是唯一的。</li><li>languages[i] 中包含的值互不相同。</li></ul><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>做麻烦了&amp;_&amp;，针对每个人存他会那种语言开bitset数组存到bitset当中。</p><p>枚举选择的语言,对于每一对关系如果<code>bitset[i]&amp;bitset[j]&gt;0</code>说明存在共同语言便continue。</p><p>如果没有公共语言的话便需要让好友<code>i、j</code>都需要学习此语言</p><p>取所有操作最小值</p><p>最后backup下即可</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumTeachings</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; languages, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; friendships)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m=languages.size(),ans=<span class="hljs-number">0x3f3f3f3f</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">bitset</span>&lt;505&gt;&gt;vec(m+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;v:languages[j]) vec[j+<span class="hljs-number">1</span>][v]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;tmp;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;it:friendships)&#123;<br>                <span class="hljs-keyword">int</span> u=it[<span class="hljs-number">0</span>],v=it[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>((vec[u]&amp;vec[v]).count()&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(!vec[u][i]) sum++,vec[u][i]=<span class="hljs-literal">true</span>,tmp.push_back(&#123;u,i&#125;);<br>                <span class="hljs-keyword">if</span>(!vec[v][i]) sum++,vec[v][i]=<span class="hljs-literal">true</span>,tmp.push_back(&#123;v,i&#125;);<br>            &#125;<br>            ans=min(ans,sum);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;it:tmp)&#123;<br>                vec[it.first][it.second]=<span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解码异或后的排列"><a href="#解码异或后的排列" class="headerlink" title="解码异或后的排列"></a>解码异或后的排列</h3><p>给你一个整数数组 <code>perm</code> ，它是前 <code>n</code> 个正整数的排列，且 <code>n</code> 是个 <strong>奇数</strong> 。</p><p>它被加密成另一个长度为 <code>n - 1</code> 的整数数组 <code>encoded </code>，满足 <code>encoded[i] = perm[i] XOR perm[i + 1]</code> 。比方说，如果 <code>perm = [1,3,2]</code> ，那么 <code>encoded = [2,1]</code> 。</p><p>给你 <code>encoded </code>数组，请你返回原始数组 <code>perm</code> 。题目保证答案存在且唯一。</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>其实如果知道a[1]的值整的序列便已知</p><p>那么如何求a[1]呢？</p><p>首先预处理<code>1~n</code>每一个二进制位<code>1</code>出现的次数为cnt[i],在预处理b的前缀异或和。</p><p>那么a[1]异或这个b的前缀和数组的每一个数字对应便是a[2]~a[n]的每一个数字。</p><p>思考对于a[1]的每一个二进制位如果是0的话结果是什么样？因为是0所以异或出来的结果0/1个数不变。那么<code>前缀和数组第i位为1的个数==cnt[i]</code>。</p><p>如果是1的话,0/1的个数调换，于是<code>前缀和数组第i位为0的个数+1==cnt[i]</code></p><p>便可求出a[1]的每一个二进制位</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">decode</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; encoded)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n=encoded.size()+<span class="hljs-number">1</span>,v=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;bit(<span class="hljs-number">20</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;cnt(<span class="hljs-number">20</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">int</span> t=i,j=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(t)&#123;<br>                <span class="hljs-keyword">if</span>(t&amp;<span class="hljs-number">1</span>) cnt[j]++;<br>                j++;<br>                t&gt;&gt;=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it:encoded)&#123;<br>            v^=it;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(v&gt;&gt;i&amp;<span class="hljs-number">1</span>) bit[i][<span class="hljs-number">1</span>]++;<br>                <span class="hljs-keyword">else</span> bit[i][<span class="hljs-number">0</span>]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;ans(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(bit[i][<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>==cnt[i]) &#123;<br>                ans[<span class="hljs-number">0</span>]+=<span class="hljs-number">1</span>&lt;&lt;i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            ans[i]=ans[i<span class="hljs-number">-1</span>]^encoded[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="生成乘积数组的方案数"><a href="#生成乘积数组的方案数" class="headerlink" title="生成乘积数组的方案数"></a>生成乘积数组的方案数</h3><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个二维整数数组 <code>queries</code> ，其中 <code>queries[i] = [ni, ki] </code>。第<code>i</code>个查询 <code>queries[i] </code>要求构造长度为 <code>ni</code> 、每个元素都是正整数的数组，且满足所有元素的乘积为 <code>ki</code> ，请你找出有多少种可行的方案。由于答案可能会很大，方案数需要对 <code>109 + 7 </code><strong>取余</strong> 。</p><p>请你返回一个整数数组 <code>answer</code>，满足 <code>answer.length == queries.length</code> ，其中 <code>answer[i]</code>是第<code> i</code> 个查询的结果。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= queries.length &lt;= 104</code></li><li><code>1 &lt;= ni, ki &lt;= 104</code></li></ul><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>组合数学。质因子数分解+插板法</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">fast_pow</span><span class="hljs-params">(ll a,ll b,ll p)</span></span>&#123;<br>        a%=p;<br>        ll res=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(b)&#123;<br>            <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res=res*a%p;<br>            a=a*a%p,b&gt;&gt;=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res%p;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e4</span>+<span class="hljs-number">7</span>,mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">int</span> fac[maxn],invfac[maxn];<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)</span></span>&#123;<span class="hljs-keyword">if</span>(m&gt;n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">1ll</span>*fac[n]*invfac[m]%mod*invfac[n-m]%mod;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)</span></span>&#123;<span class="hljs-keyword">if</span>(m&gt;n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">1ll</span>*fac[n]*invfac[n-m]%mod;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">C_init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span></span>&#123;<br>        fac[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;<br>            fac[i] = <span class="hljs-number">1ll</span>*fac[i<span class="hljs-number">-1</span>]*i%mod;<br>        &#125;<br>        invfac[N] = fast_pow(fac[N],mod<span class="hljs-number">-2</span>,mod);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=N<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) invfac[i] = <span class="hljs-number">1ll</span>*invfac[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">waysToFillArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;<br>        C_init(<span class="hljs-number">10005</span>);<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;it:queries)&#123;<br>            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;vec;<br>            <span class="hljs-keyword">int</span> n=it[<span class="hljs-number">0</span>],m=it[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=m;i++)&#123;<br>                <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span>(m%i==<span class="hljs-number">0</span>)&#123;<br>                    cnt++;<br>                    m/=i;<br>                &#125;<br>                vec.push_back(cnt);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(m!=<span class="hljs-number">1</span>) vec.push_back(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">int</span> ans=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;v:vec)&#123;<br>                ans=(<span class="hljs-number">1ll</span>*ans*(<span class="hljs-keyword">int</span>)C(v+n<span class="hljs-number">-1</span>,n<span class="hljs-number">-1</span>))%mod;<br>            &#125;<br>            res.push_back(ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer题解</title>
    <link href="/2021/03/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    <url>/2021/03/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指offer03-数组中重复的数字"><a href="#剑指offer03-数组中重复的数字" class="headerlink" title="剑指offer03-数组中重复的数字"></a>剑指offer03-数组中重复的数字</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h3><p><strong>Hashset</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt;se;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;v:nums)&#123;<br>            <span class="hljs-keyword">if</span>(se.count(v)) <span class="hljs-keyword">return</span> v;<br>            se.insert(v);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>时间复杂度O（n） 空间复杂度O（n）</p></blockquote><h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><p><strong>暴力交换</strong></p><p>由于所有数字范围0~n-1，即可将数字i交换到i位置即可,即需要满足<code>nums[i]==i</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n=nums.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.size();i++)&#123;<br>            <span class="hljs-keyword">while</span>(nums[i]!=i&amp;&amp;nums[nums[i]]!=nums[i]) swap(nums[i],nums[nums[i]]);<span class="hljs-comment">//交换到指定位置</span><br>            <span class="hljs-keyword">if</span>(nums[i]!=i&amp;&amp;nums[i]==nums[nums[i]]) <span class="hljs-keyword">return</span> nums[i];<span class="hljs-comment">//当前数字不在指定位置并且目标位置有相同的数字</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指offer-04-二维数组中的查找"><a href="#剑指offer-04-二维数组中的查找" class="headerlink" title="剑指offer 04-二维数组中的查找"></a>剑指offer 04-二维数组中的查找</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 <code>true</code>。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n=matrix.size();<br>        <span class="hljs-keyword">if</span>(!n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">int</span> m=matrix[<span class="hljs-number">0</span>].size();<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=m<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&gt;=<span class="hljs-number">0</span>&amp;&amp;i&lt;n&amp;&amp;j&lt;m)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j]==target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(matrix[i][j]&lt;target) i++;<br>            <span class="hljs-keyword">else</span> j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指offer-05-替换空格"><a href="#剑指offer-05-替换空格" class="headerlink" title="剑指offer 05-替换空格"></a>剑指offer 05-替换空格</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>语法题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">replaceSpace</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    <span class="hljs-keyword">return</span> strings.Replace(s, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;%20&quot;</span>, <span class="hljs-number">-1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指offer-06-从尾到头打印链表"><a href="#剑指offer-06-从尾到头打印链表" class="headerlink" title="剑指offer 06-从尾到头打印链表"></a>剑指offer 06-从尾到头打印链表</h2><p><strong>题意</strong></p><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;vec;<br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            vec.push_back(head-&gt;val);<br>            head=head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&#123;vec.rbegin(),vec.rend()&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
